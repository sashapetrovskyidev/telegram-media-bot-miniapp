<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>My Studio</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        canvas { display: block; }
    </style>
</head>
<body>
<script>
    // --- GLOBAL MAP STYLE ---
    // 'default', 'realistic', or 'anime'
    window.mapStyle = 'default';

    // Map style to room image filenames
    const MAP_STYLES = {
        'default':   { room1: 'room1.png',           room2: 'room__2.png' },
        'realistic': { room1: 'room1_realistic.png',  room2: 'room2_realistic.png' },
        'anime':     { room1: 'room1_anime.png',      room2: 'room2_anime.png' },
    };

    // --- START MENU SCENE ---
    class MenuScene extends Phaser.Scene {
        constructor() { super('MenuScene'); }

        preload() {
            this.load.image('menuBg', 'menu_bg.jpg');
            this.load.image('menuUI', 'menu.png');

            this.load.on('loaderror', (file) => {
                console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏: ' + file.key);
            });
        }

        create() {
            const { width, height } = this.scale;

            // Full-screen studio artwork background
            const bg = this.add.image(width / 2, height / 2, 'menuBg');
            const bgScaleX = width / bg.width;
            const bgScaleY = height / bg.height;
            const bgScale = Math.max(bgScaleX, bgScaleY);
            bg.setScale(bgScale);

            // Dark overlay ‚Äî subtle, let the artwork show through
            const overlay = this.add.graphics();
            overlay.fillStyle(0x000000, 0.3);
            overlay.fillRect(0, 0, width, height);

            // --- PIXEL-ART MENU BOX (transparent) ---
            const boxW = 620;
            const boxH = 380;
            const boxX = width / 2 - boxW / 2;
            const boxY = height / 2 - boxH / 2 - 60;

            // Main menu box ‚Äî semi-transparent with pixel border
            const menuBox = this.add.graphics();
            // Outer border (lighter grey, semi-transparent)
            menuBox.fillStyle(0x6b7a8d, 0.5);
            menuBox.fillRect(boxX - 6, boxY - 6, boxW + 12, boxH + 12);
            // Inner border (medium, semi-transparent)
            menuBox.fillStyle(0x4a5568, 0.5);
            menuBox.fillRect(boxX - 3, boxY - 3, boxW + 6, boxH + 6);
            // Background fill (transparent dark)
            menuBox.fillStyle(0x2d3748, 0.55);
            menuBox.fillRect(boxX, boxY, boxW, boxH);
            // Inner highlight line (top)
            menuBox.fillStyle(0x4a5568, 0.4);
            menuBox.fillRect(boxX + 4, boxY + 4, boxW - 8, 2);
            // Inner shadow line (bottom)
            menuBox.fillStyle(0x1a202c, 0.4);
            menuBox.fillRect(boxX + 4, boxY + boxH - 6, boxW - 8, 2);

            // "WERYPEAS STUDIO" title
            const title = this.add.text(width / 2, boxY + 75, 'WERYPEAS\nSTUDIO', {
                fontSize: '64px',
                fontFamily: 'Courier New, monospace',
                color: '#e2e8f0',
                fontStyle: 'bold',
                stroke: '#000000',
                strokeThickness: 8,
                align: 'center'
            }).setOrigin(0.5);

            // Subtle title pulse
            this.tweens.add({
                targets: title,
                alpha: { from: 0.85, to: 1 },
                duration: 2000,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });

            // --- BUTTONS (pixel-art style matching mockup) ---
            const btnW = 380;
            const btnH = 60;

            this.createMenuButton(width / 2, boxY + 175, btnW, btnH, 'START GAME', () => {
                this.cameras.main.fadeOut(500, 0, 0, 0);
                this.time.delayedCall(500, () => {
                    this.scene.start('MainScene');
                });
            });

            this.createMenuButton(width / 2, boxY + 260, btnW, btnH, 'OPTIONS', () => {
                this.showOptionsPanel(width, height);
            });

            // Options panel container (hidden initially)
            this.optionsContainer = this.add.container(0, 0).setVisible(false).setDepth(200);

            this.cameras.main.fadeIn(800, 0, 0, 0);
        }

        showOptionsPanel(width, height) {
            if (this.optionsContainer.visible) {
                this.optionsContainer.setVisible(false);
                return;
            }

            // Clear previous content
            this.optionsContainer.removeAll(true);

            // Darken background
            const dimBg = this.add.rectangle(width / 2, height / 2, width, height, 0x000000, 0.5)
                .setInteractive();
            this.optionsContainer.add(dimBg);

            // Options box
            const panelW = 560;
            const panelH = 420;
            const px = width / 2 - panelW / 2;
            const py = height / 2 - panelH / 2;

            const panelGfx = this.add.graphics();
            // Border
            panelGfx.fillStyle(0x6b7a8d, 0.6);
            panelGfx.fillRect(px - 6, py - 6, panelW + 12, panelH + 12);
            panelGfx.fillStyle(0x4a5568, 0.6);
            panelGfx.fillRect(px - 3, py - 3, panelW + 6, panelH + 6);
            // Background
            panelGfx.fillStyle(0x1a202c, 0.9);
            panelGfx.fillRect(px, py, panelW, panelH);
            this.optionsContainer.add(panelGfx);

            // Title
            const optTitle = this.add.text(width / 2, py + 45, 'MAP STYLE', {
                fontSize: '40px',
                fontFamily: 'Courier New',
                color: '#e2e8f0',
                fontStyle: 'bold',
                stroke: '#000000',
                strokeThickness: 4
            }).setOrigin(0.5);
            this.optionsContainer.add(optTitle);

            // Style options
            const styles = [
                { key: 'default',   label: 'DEFAULT',   desc: 'Pixel art rooms' },
                { key: 'realistic', label: 'REALISTIC',  desc: 'Realistic style rooms' },
                { key: 'anime',     label: 'ANIME',      desc: 'Anime style rooms' },
            ];

            const optBtnW = 440;
            const optBtnH = 70;
            const startY = py + 110;

            styles.forEach((style, i) => {
                const by = startY + i * 90;
                const isSelected = window.mapStyle === style.key;

                const sBtnGfx = this.add.graphics();
                // Border
                sBtnGfx.fillStyle(isSelected ? 0x48bb78 : 0x6b7a8d, 0.6);
                sBtnGfx.fillRect(width/2 - optBtnW/2 - 3, by - 3, optBtnW + 6, optBtnH + 6);
                // Background
                sBtnGfx.fillStyle(isSelected ? 0x2f855a : 0x2d3748, isSelected ? 0.7 : 0.6);
                sBtnGfx.fillRect(width/2 - optBtnW/2, by, optBtnW, optBtnH);
                this.optionsContainer.add(sBtnGfx);

                // Checkmark or bullet
                const marker = this.add.text(width/2 - optBtnW/2 + 30, by + optBtnH/2, isSelected ? '>' : ' ', {
                    fontSize: '32px',
                    fontFamily: 'Courier New',
                    color: isSelected ? '#48bb78' : '#64748b',
                    fontStyle: 'bold'
                }).setOrigin(0.5);
                this.optionsContainer.add(marker);

                // Label
                const sLabel = this.add.text(width/2 - 20, by + optBtnH/2 - 8, style.label, {
                    fontSize: '32px',
                    fontFamily: 'Courier New',
                    color: isSelected ? '#ffffff' : '#cbd5e1',
                    fontStyle: 'bold',
                    stroke: '#000000',
                    strokeThickness: 2
                }).setOrigin(0.5);
                this.optionsContainer.add(sLabel);

                // Description
                const sDesc = this.add.text(width/2 - 20, by + optBtnH/2 + 18, style.desc, {
                    fontSize: '20px',
                    fontFamily: 'Courier New',
                    color: isSelected ? '#c6f6d5' : '#94a3b8',
                }).setOrigin(0.5);
                this.optionsContainer.add(sDesc);

                // Hit area
                const sHit = this.add.rectangle(width/2, by + optBtnH/2, optBtnW, optBtnH, 0x000000, 0)
                    .setInteractive({ useHandCursor: true });
                this.optionsContainer.add(sHit);

                sHit.on('pointerover', () => {
                    if (window.mapStyle !== style.key) {
                        sBtnGfx.clear();
                        sBtnGfx.fillStyle(0x8a9bb0, 0.6);
                        sBtnGfx.fillRect(width/2 - optBtnW/2 - 3, by - 3, optBtnW + 6, optBtnH + 6);
                        sBtnGfx.fillStyle(0x3d4a5c, 0.7);
                        sBtnGfx.fillRect(width/2 - optBtnW/2, by, optBtnW, optBtnH);
                    }
                });

                sHit.on('pointerout', () => {
                    if (window.mapStyle !== style.key) {
                        sBtnGfx.clear();
                        sBtnGfx.fillStyle(0x6b7a8d, 0.6);
                        sBtnGfx.fillRect(width/2 - optBtnW/2 - 3, by - 3, optBtnW + 6, optBtnH + 6);
                        sBtnGfx.fillStyle(0x2d3748, 0.6);
                        sBtnGfx.fillRect(width/2 - optBtnW/2, by, optBtnW, optBtnH);
                    }
                });

                sHit.on('pointerdown', () => {
                    window.mapStyle = style.key;
                    // Refresh the panel to show new selection
                    this.showOptionsPanel(width, height);
                });
            });

            // BACK button
            const backY = startY + 3 * 90 + 10;
            const backGfx = this.add.graphics();
            backGfx.fillStyle(0x6b7a8d, 0.5);
            backGfx.fillRect(width/2 - 100 - 3, backY - 3, 206, 52);
            backGfx.fillStyle(0x4a5568, 0.6);
            backGfx.fillRect(width/2 - 100, backY, 200, 46);
            this.optionsContainer.add(backGfx);

            const backText = this.add.text(width / 2, backY + 23, 'BACK', {
                fontSize: '30px',
                fontFamily: 'Courier New',
                color: '#e2e8f0',
                fontStyle: 'bold',
                stroke: '#000000',
                strokeThickness: 2
            }).setOrigin(0.5);
            this.optionsContainer.add(backText);

            const backHit = this.add.rectangle(width/2, backY + 23, 200, 46, 0x000000, 0)
                .setInteractive({ useHandCursor: true });
            this.optionsContainer.add(backHit);

            backHit.on('pointerdown', () => {
                this.optionsContainer.setVisible(false);
            });

            this.optionsContainer.setVisible(true);
        }

        createMenuButton(x, y, w, h, text, callback) {
            const btnGfx = this.add.graphics();

            // Outer border (semi-transparent)
            btnGfx.fillStyle(0x8a9bb0, 0.5);
            btnGfx.fillRect(x - w/2 - 4, y - h/2 - 4, w + 8, h + 8);
            // Inner border
            btnGfx.fillStyle(0x5a6b7d, 0.5);
            btnGfx.fillRect(x - w/2 - 2, y - h/2 - 2, w + 4, h + 4);
            // Button background (transparent)
            btnGfx.fillStyle(0x4a5568, 0.55);
            btnGfx.fillRect(x - w/2, y - h/2, w, h);
            // Top highlight
            btnGfx.fillStyle(0x5a6b7d, 0.4);
            btnGfx.fillRect(x - w/2 + 3, y - h/2 + 3, w - 6, 2);

            const hitArea = this.add.rectangle(x, y, w, h, 0x000000, 0)
                .setInteractive({ useHandCursor: true });

            const btnText = this.add.text(x, y, text, {
                fontSize: '36px',
                fontFamily: 'Courier New',
                color: '#e2e8f0',
                fontStyle: 'bold',
                stroke: '#000000',
                strokeThickness: 3
            }).setOrigin(0.5);

            hitArea.on('pointerover', () => {
                btnGfx.clear();
                btnGfx.fillStyle(0x8a9bb0, 0.6);
                btnGfx.fillRect(x - w/2 - 4, y - h/2 - 4, w + 8, h + 8);
                btnGfx.fillStyle(0x5a6b7d, 0.6);
                btnGfx.fillRect(x - w/2 - 2, y - h/2 - 2, w + 4, h + 4);
                btnGfx.fillStyle(0x5a6b7d, 0.65);
                btnGfx.fillRect(x - w/2, y - h/2, w, h);
                btnGfx.fillStyle(0x6b7d8f, 0.5);
                btnGfx.fillRect(x - w/2 + 3, y - h/2 + 3, w - 6, 2);
                btnText.setColor('#ffffff');
            });

            hitArea.on('pointerout', () => {
                btnGfx.clear();
                btnGfx.fillStyle(0x8a9bb0, 0.5);
                btnGfx.fillRect(x - w/2 - 4, y - h/2 - 4, w + 8, h + 8);
                btnGfx.fillStyle(0x5a6b7d, 0.5);
                btnGfx.fillRect(x - w/2 - 2, y - h/2 - 2, w + 4, h + 4);
                btnGfx.fillStyle(0x4a5568, 0.55);
                btnGfx.fillRect(x - w/2, y - h/2, w, h);
                btnGfx.fillStyle(0x5a6b7d, 0.4);
                btnGfx.fillRect(x - w/2 + 3, y - h/2 + 3, w - 6, 2);
                btnText.setColor('#e2e8f0');
            });

            hitArea.on('pointerdown', () => {
                this.tweens.add({
                    targets: [btnGfx, hitArea, btnText],
                    scale: 0.95,
                    duration: 80,
                    yoyo: true,
                    onComplete: callback
                });
            });
        }
    }

    // --- –ì–õ–ê–í–ù–ê–Ø –°–¶–ï–ù–ê (–ì–û–°–¢–ò–ù–ê–Ø) ---
    class MainScene extends Phaser.Scene {
        constructor() { super('MainScene'); }

        preload() {
            console.log('üîÑ –ù–∞—á–∏–Ω–∞–µ–º –∑–∞–≥—Ä—É–∑–∫—É —Ä–µ—Å—É—Ä—Å–æ–≤...');

            // Load room based on selected map style
            const style = MAP_STYLES[window.mapStyle] || MAP_STYLES['default'];
            this.load.image('room1', style.room1);

            // –ö–†–ò–¢–ò–ß–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–≥—Ä—É–∑–∫—É —Å–ø—Ä–∞–π—Ç—à–∏—Ç–∞
            this.load.spritesheet('playerSprite', 'person_model.png', {
                frameWidth: 512,
                frameHeight: 512
            });

            // --- INTERACTION OVERLAYS for Room 1 (Living Room) ---
            // Guitar, PS5 controller line, PS5 controller+TV action ‚Äî all 1952x2176 matching room1
            this.load.image('line_guitar', 'action_guitar.png');
            this.load.image('line_ps_controller', 'action_ps_controller.png');
            this.load.image('action_ps_controller_tv', 'action_ps_controller_tv.png');

            this.load.on('loaderror', (file) => {
                console.error('‚ùå –û–®–ò–ë–ö–ê –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–∞: ' + file.key);
                console.error('‚ùå –ü—É—Ç—å –∫ —Ñ–∞–π–ª—É:', file.url);
            });

            this.load.on('complete', () => {
                console.log('‚úÖ –í—Å–µ —Ñ–∞–π–ª—ã –∑–∞–≥—Ä—É–∂–µ–Ω—ã! Style:', window.mapStyle);
            });
        }

        create() {
            const screenWidth = this.scale.width;
            const screenHeight = this.scale.height;

            const bg = this.add.image(0, 0, 'room1').setOrigin(0, 0);

            const scaleX = screenWidth / bg.width;
            const scaleY = screenHeight / bg.height;
            const scale = Math.max(scaleX, scaleY);

            bg.setScale(scale);

            const roomWidth = bg.width * scale;
            const roomHeight = bg.height * scale;

            this.physics.world.setBounds(0, 0, roomWidth, roomHeight);

            // –°–æ–∑–¥–∞–Ω–∏–µ –∞–Ω–∏–º–∞—Ü–∏–π –¥–ª—è –ù–û–í–û–ì–û —Å–ø—Ä–∞–π—Ç—à–∏—Ç–∞
            if (!this.anims.exists('walk-down')) {
                // DOWN (—Å–ø–∏–Ω–æ–π, —Ä—è–¥ 0) - —Ñ—Ä–µ–π–º—ã 0,1,2,3
                this.anims.create({
                    key: 'walk-down',
                    frames: this.anims.generateFrameNumbers('playerSprite', { start: 0, end: 3 }),
                    frameRate: 8,
                    repeat: -1
                });

                // LEFT (–≤–ª–µ–≤–æ, —Ä—è–¥ 1) - —Ñ—Ä–µ–π–º—ã 4,5,6,7
                this.anims.create({
                    key: 'walk-left',
                    frames: this.anims.generateFrameNumbers('playerSprite', { start: 4, end: 7 }),
                    frameRate: 8,
                    repeat: -1
                });

                // UP (–Ω–∞–∑–∞–¥/–≤–≤–µ—Ä—Ö, —Ä—è–¥ 2) - —Ñ—Ä–µ–π–º—ã 8,9,10,11
                this.anims.create({
                    key: 'walk-up',
                    frames: this.anims.generateFrameNumbers('playerSprite', { start: 8, end: 11 }),
                    frameRate: 8,
                    repeat: -1
                });

                // RIGHT (–≤–ø—Ä–∞–≤–æ, —Ä—è–¥ 3) - —Ñ—Ä–µ–π–º—ã 12,13,14,15
                this.anims.create({
                    key: 'walk-right',
                    frames: this.anims.generateFrameNumbers('playerSprite', { start: 12, end: 15 }),
                    frameRate: 8,
                    repeat: -1
                });

                // IDLE –∞–Ω–∏–º–∞—Ü–∏–∏ (—Å—Ç–æ—è—â–∏–π –ø–µ—Ä—Å–æ–Ω–∞–∂ - –∫–∞–¥—Ä 0 –∏–ª–∏ 2 –≤ –∫–∞–∂–¥–æ–º —Ä—è–¥—É)
                this.anims.create({
                    key: 'idle-down',
                    frames: [{ key: 'playerSprite', frame: 0 }]
                });

                this.anims.create({
                    key: 'idle-left',
                    frames: [{ key: 'playerSprite', frame: 4 }]
                });

                this.anims.create({
                    key: 'idle-up',
                    frames: [{ key: 'playerSprite', frame: 8 }]
                });

                this.anims.create({
                    key: 'idle-right',
                    frames: [{ key: 'playerSprite', frame: 12 }]
                });
            }

            // –ü–µ—Ä—Å–æ–Ω–∞–∂ ‚Äî spawn inside walkable isometric floor area
            const fromStudio = this.scene.settings.data?.fromStudio;

            if (fromStudio) {
                // Coming from studio ‚Äî spawn on floor between ottoman and right side
                this.player = this.physics.add.sprite(roomWidth * 0.50, roomHeight * 0.72, 'playerSprite');
            } else {
                // First time ‚Äî spawn in center of floor (between sofa and ottoman)
                this.player = this.physics.add.sprite(roomWidth * 0.55, roomHeight * 0.75, 'playerSprite');
            }

            console.log('üë§ –°–æ–∑–¥–∞–Ω–∏–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∞...');
            console.log('üë§ Texture exists?', this.textures.exists('playerSprite'));

            // –£–º–µ–Ω—å—à–∞–µ–º —Ä–∞–∑–º–µ—Ä –ø–µ—Ä—Å–æ–Ω–∞–∂–∞
            this.player.setScale(0.5);  // –ë—ã–ª–æ 3, —Ç–µ–ø–µ—Ä—å 2
            this.player.setOrigin(0.5, 1); // –í–ê–ñ–ù–û: origin –≤–Ω–∏–∑—É –ø–æ —Ü–µ–Ω—Ç—Ä—É (–¥–ª—è –Ω–æ–≥)
            this.player.setCollideWorldBounds(true);

            // –•–∏—Ç–±–æ–∫—Å –¥–ª—è –Ω–æ–≥
            this.player.body.setSize(20, 10);  // –ú–∞–ª–µ–Ω—å–∫–∏–π —Ö–∏—Ç–±–æ–∫—Å
            this.player.body.setOffset(22, 54); // –°–º–µ—â–µ–Ω–∏–µ –∫ —Å–∞–º–æ–º—É –Ω–∏–∑—É (–Ω–æ–≥–∏)

            this.player.anims.play('idle-down');
            this.playerDirection = 'down';

            console.log('üë§ –ü–µ—Ä—Å–æ–Ω–∞–∂ —Å–æ–∑–¥–∞–Ω –Ω–∞ –ø–æ–∑–∏—Ü–∏–∏:', this.player.x, this.player.y);
            console.log('üë§ –†–∞–∑–º–µ—Ä —Å–ø—Ä–∞–π—Ç–∞:', this.player.width, 'x', this.player.height);
            console.log('üë§ Frame size:', this.player.frame.width, 'x', this.player.frame.height);

            // –ö–ê–ú–ï–†–ê –í–°–ï–ì–î–ê –°–õ–ï–î–£–ï–¢ –ó–ê –ü–ï–†–°–û–ù–ê–ñ–ï–ú + –ó–£–ú
            this.cameras.main.startFollow(this.player, true, 0.1, 0.1);
            this.cameras.main.setBounds(0, 0, roomWidth, roomHeight);
            this.cameras.main.setZoom(1.4); // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –∑—É–º
            this.cameras.main.fadeIn(1000, 0, 0, 0);

            this.targetX = null;
            this.targetY = null;
            this.isTransitioning = false;

            // --- WASD –£–ü–†–ê–í–õ–ï–ù–ò–ï ---
            this.cursors = this.input.keyboard.createCursorKeys();
            this.wasd = this.input.keyboard.addKeys({
                up: Phaser.Input.Keyboard.KeyCodes.W,
                down: Phaser.Input.Keyboard.KeyCodes.S,
                left: Phaser.Input.Keyboard.KeyCodes.A,
                right: Phaser.Input.Keyboard.KeyCodes.D
            });

            // --- –í–ò–†–¢–£–ê–õ–¨–ù–´–ï –°–¢–†–ï–õ–ö–ò (–¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö) ---
            const buttonSize = 80;
            const buttonAlpha = 0.6;
            const buttonColor = 0x444444;

            // –õ–µ–≤–∞—è —Å—Ç—Ä–µ–ª–∫–∞
            this.btnLeft = this.add.circle(120, screenHeight - 150, buttonSize/2, buttonColor, buttonAlpha);
            this.btnLeft.setScrollFactor(0).setInteractive();
            this.add.text(120, screenHeight - 150, '‚óÑ', {
                fontSize: '50px', color: '#ffffff'
            }).setOrigin(0.5).setScrollFactor(0);

            // –ü—Ä–∞–≤–∞—è —Å—Ç—Ä–µ–ª–∫–∞
            this.btnRight = this.add.circle(280, screenHeight - 150, buttonSize/2, buttonColor, buttonAlpha);
            this.btnRight.setScrollFactor(0).setInteractive();
            this.add.text(280, screenHeight - 150, '‚ñ∫', {
                fontSize: '50px', color: '#ffffff'
            }).setOrigin(0.5).setScrollFactor(0);

            // –í–µ—Ä—Ö–Ω—è—è —Å—Ç—Ä–µ–ª–∫–∞
            this.btnUp = this.add.circle(screenWidth - 120, screenHeight - 230, buttonSize/2, buttonColor, buttonAlpha);
            this.btnUp.setScrollFactor(0).setInteractive();
            this.add.text(screenWidth - 120, screenHeight - 230, '‚ñ≤', {
                fontSize: '50px', color: '#ffffff'
            }).setOrigin(0.5).setScrollFactor(0);

            // –ù–∏–∂–Ω—è—è —Å—Ç—Ä–µ–ª–∫–∞
            this.btnDown = this.add.circle(screenWidth - 120, screenHeight - 70, buttonSize/2, buttonColor, buttonAlpha);
            this.btnDown.setScrollFactor(0).setInteractive();
            this.add.text(screenWidth - 120, screenHeight - 70, '‚ñº', {
                fontSize: '50px', color: '#ffffff'
            }).setOrigin(0.5).setScrollFactor(0);

            // –°–æ—Å—Ç–æ—è–Ω–∏—è –≤–∏—Ä—Ç—É–∞–ª—å–Ω—ã—Ö –∫–Ω–æ–ø–æ–∫
            this.virtualInput = { left: false, right: false, up: false, down: false };

            this.btnLeft.on('pointerdown', () => { this.virtualInput.left = true; });
            this.btnLeft.on('pointerup', () => { this.virtualInput.left = false; });
            this.btnLeft.on('pointerout', () => { this.virtualInput.left = false; });

            this.btnRight.on('pointerdown', () => { this.virtualInput.right = true; });
            this.btnRight.on('pointerup', () => { this.virtualInput.right = false; });
            this.btnRight.on('pointerout', () => { this.virtualInput.right = false; });

            this.btnUp.on('pointerdown', () => { this.virtualInput.up = true; });
            this.btnUp.on('pointerup', () => { this.virtualInput.up = false; });
            this.btnUp.on('pointerout', () => { this.virtualInput.up = false; });

            this.btnDown.on('pointerdown', () => { this.virtualInput.down = true; });
            this.btnDown.on('pointerup', () => { this.virtualInput.down = false; });
            this.btnDown.on('pointerout', () => { this.virtualInput.down = false; });

            // –ö–ª–∏–∫ –ø–æ –∫–∞—Ä—Ç–µ (–æ—Å—Ç–∞–≤–ª—è–µ–º –¥–ª—è PC)
            this.input.on('pointerdown', (pointer) => {
                if (this.isTransitioning) return;

                // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∫–ª–∏–∫–∏ –ø–æ –∫–Ω–æ–ø–∫–∞–º
                if (pointer.y > screenHeight - 300) return;

                const worldPoint = this.cameras.main.getWorldPoint(pointer.x, pointer.y);
                this.targetX = worldPoint.x;
                this.targetY = worldPoint.y;
                this.physics.moveToObject(this.player, worldPoint, 250);
            });

            // === ROOM 1 ‚Äî POLYGON-BASED ISOMETRIC COLLISIONS ===
            //
            // Instead of axis-aligned rectangles, we define the walkable floor
            // as isometric polygons matching the actual visible floor tiles.
            // The update() loop checks if player feet are inside walkable area.
            //
            // ROOM 1 FLOOR LAYOUT (from movement image):
            // The walkable area traces the actual floor visible between furniture.
            // In isometric view, "up-left" on screen = north in game world.
            //
            // Walkable zone = outer polygon MINUS ottoman polygon (hole).
            //
            // Outer walkable polygon (tracing red lines from image):
            // The red boundary follows the floor edges between sofa and TV stand.
            //   P1: left of sofa bottom-front ‚Üí going clockwise
            //
            // Looking at the image carefully:
            //   - Sofa is on the LEFT wall, takes up the left portion
            //   - Ottoman/pouf is in the CENTER of the floor
            //   - TV stand is along the BACK wall (top of isometric view)
            //   - Door is on the RIGHT wall
            //   - Floor is visible as a diamond between all furniture
            //
            // The red boundary in the image forms a shape following the floor:

            // Store walkable polygon and ottoman polygon for update() checks
            // All coordinates as fractions of roomWidth/roomHeight

            // OUTER walkable boundary ‚Äî traces the FLOOR ONLY
            // Carefully traced from movement image (room1_movements.png)
            //
            // The red rectangle in the image follows the isometric floor edges:
            //   - LEFT side: runs along the sofa's RIGHT arm (inner edge facing floor)
            //   - TOP side: runs along the TV stand's BOTTOM edge (floor in front of TV)
            //   - RIGHT side: runs along the door area / right wall floor edge
            //   - BOTTOM side: the front visible floor edge
            //
            // Going clockwise from top-left
            this.walkablePolygon = [
                { x: 0.20, y: 0.60 },  // Top-left: where sofa meets TV stand area (floor only)
                { x: 0.44, y: 0.48 },  // Top-center: floor edge right below TV stand
                { x: 0.67, y: 0.60 },  // Top-right: floor near door / right of TV stand
                { x: 0.74, y: 0.57 },  // Right: floor in front of door
                { x: 0.90, y: 0.65 },  // Bottom-right: right side floor front edge
                { x: 0.50, y: 0.80 },  // Bottom-center: front floor tip
				{ x: 0.485, y: 0.70 }, // near sofa right side
				{ x: 0.46, y: 0.695 }, // near sofa right side
				{ x: 0.43, y: 0.71 }, // near sofa right side
			];

            // OTTOMAN / POUF ‚Äî centered on the actual ottoman furniture
            // Traced tightly around the ottoman visible in the room
            this.ottomanPolygon = [
                { x: 0.32, y: 0.60 },  // From a TOP DOWN LOOK: Left corner
                { x: 0.41, y: 0.56 },  // Top corner
                { x: 0.50, y: 0.60 },  // Right corner
                { x: 0.41, y: 0.65 },  // Bottom corner
            ];

            this.roomWidth = roomWidth;
            this.roomHeight = roomHeight;

            // GREEN TRANSITION LINE ‚Äî diagonal from movement image
            // In the image: green line goes from bottom-center area toward upper-right
            // roughly from (0.44, 0.86) to (0.74, 0.60) ‚Äî a "/" diagonal
            this.greenLineStart = { x: 0.50, y: 0.80 };
            this.greenLineEnd = { x: 0.90, y: 0.65 };

            // Locked door zone (right wall ‚Äî isometric diamond near the door)
            this.lockedDoorPoly = [
                { x: 0.74, y: 0.48 },
                { x: 0.86, y: 0.52 },
                { x: 0.86, y: 0.62 },
                { x: 0.74, y: 0.58 },
            ];
            this.lockedDoorMessage = this.add.text(roomWidth * 0.75, roomHeight * 0.35,
                '–ï—â–µ –Ω–µ –≤—Ä–µ–º—è', {
                fontSize: '48px',
                fontFamily: 'Courier New',
                color: '#ffffff',
                backgroundColor: '#000000',
                padding: { x: 25, y: 12 },
                alpha: 0
            }).setOrigin(0.5).setDepth(100);
            this.lockedDoorTimer = 0;

            // DEBUG: Draw the polygons so we can see them
            const debugGfx = this.add.graphics();
            debugGfx.setDepth(50);

            // Draw outer walkable polygon (red outline)
            debugGfx.lineStyle(3, 0xff0000, 0.8);
            debugGfx.beginPath();
            this.walkablePolygon.forEach((p, i) => {
                const px = p.x * roomWidth;
                const py = p.y * roomHeight;
                if (i === 0) debugGfx.moveTo(px, py);
                else debugGfx.lineTo(px, py);
            });
            debugGfx.closePath();
            debugGfx.strokePath();

            // Draw ottoman (red filled)
            debugGfx.lineStyle(3, 0xff0000, 0.8);
            debugGfx.fillStyle(0xff0000, 0.15);
            debugGfx.beginPath();
            this.ottomanPolygon.forEach((p, i) => {
                const px = p.x * roomWidth;
                const py = p.y * roomHeight;
                if (i === 0) debugGfx.moveTo(px, py);
                else debugGfx.lineTo(px, py);
            });
            debugGfx.closePath();
            debugGfx.strokePath();
            debugGfx.fillPath();

            // Draw green transition line
            debugGfx.lineStyle(4, 0x00ff00, 0.8);
            debugGfx.beginPath();
            debugGfx.moveTo(this.greenLineStart.x * roomWidth, this.greenLineStart.y * roomHeight);
            debugGfx.lineTo(this.greenLineEnd.x * roomWidth, this.greenLineEnd.y * roomHeight);
            debugGfx.strokePath();

            // Draw locked door zone
            debugGfx.lineStyle(2, 0xffff00, 0.6);
            debugGfx.beginPath();
            this.lockedDoorPoly.forEach((p, i) => {
                if (i === 0) debugGfx.moveTo(p.x * roomWidth, p.y * roomHeight);
                else debugGfx.lineTo(p.x * roomWidth, p.y * roomHeight);
            });
            debugGfx.closePath();
            debugGfx.strokePath();

            // === INTERACTION SYSTEM ===
            // Define interactive items with proximity zones and overlays
            // Each item: { id, proximityCenter {x,y} as fraction, proximityRadius in pixels,
            //              lineOverlay: texture key, actionOverlay: texture key (or null) }
            this.interactiveItems = [
                {
                    id: 'guitar',
                    // Guitar ‚Äî mounted on the LEFT wall of living room
                    proximityCenter: { x: 0.25, y: 0.60 },
                    proximityRadius: 90,
                    lineOverlay: 'line_guitar',
                    actionOverlay: null,
                },
                {
                    id: 'ps_controller',
                    // PS5 controller + TV ‚Äî on the TV stand, back wall
                    proximityCenter: { x: 0.65, y: 0.60 },
                    proximityRadius: 100,
                    lineOverlay: 'line_ps_controller',
                    actionOverlay: 'action_ps_controller_tv',
                },
            ];

            // Create overlay sprites for each item (same size as room, layered on top)
            this.interactiveItems.forEach(item => {
                // Line/glow overlay ‚Äî shows when player is near
                item.lineSprite = this.add.image(0, 0, item.lineOverlay).setOrigin(0, 0);
                item.lineSprite.setScale(scale);
                item.lineSprite.setVisible(false);
                item.lineSprite.setDepth(10);

                // Action overlay ‚Äî shows when E is pressed (if separate)
                if (item.actionOverlay) {
                    item.actionSprite = this.add.image(0, 0, item.actionOverlay).setOrigin(0, 0);
                    item.actionSprite.setScale(scale);
                    item.actionSprite.setVisible(false);
                    item.actionSprite.setDepth(10);
                } else {
                    item.actionSprite = null;
                }

                // State: 'idle' | 'near' | 'active'
                item.state = 'idle';
            });

            // DEBUG: Draw yellow interaction zones
            this.interactiveItems.forEach(item => {
                const cx = item.proximityCenter.x * roomWidth;
                const cy = item.proximityCenter.y * roomHeight;
                debugGfx.lineStyle(2, 0xffff00, 0.8);
                debugGfx.fillStyle(0xffff00, 0.1);
                debugGfx.strokeCircle(cx, cy, item.proximityRadius);
                debugGfx.fillCircle(cx, cy, item.proximityRadius);
                // Label
                const label = this.add.text(cx, cy - item.proximityRadius - 10, item.id, {
                    fontSize: '18px', fontFamily: 'Courier New', color: '#ffff00',
                    stroke: '#000000', strokeThickness: 3
                }).setOrigin(0.5).setDepth(51);
            });

            // DEBUG: Player dot that turns white when in interaction zone
            this.debugPlayerDot = this.add.circle(0, 0, 8, 0x00ff00, 0.9).setDepth(55);

            // Currently active item (only one action at a time)
            this.activeInteraction = null;

            // E key prompt (floating above player, hidden by default)
            this.ePrompt = this.add.text(0, 0, '[E]', {
                fontSize: '36px',
                fontFamily: 'Courier New',
                color: '#ffffff',
                backgroundColor: '#000000aa',
                padding: { x: 12, y: 6 },
                fontStyle: 'bold'
            }).setOrigin(0.5).setDepth(150).setVisible(false);

            // Pulsing animation for E prompt
            this.tweens.add({
                targets: this.ePrompt,
                alpha: { from: 0.6, to: 1 },
                scaleX: { from: 0.95, to: 1.05 },
                scaleY: { from: 0.95, to: 1.05 },
                duration: 800,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });

            // E key input
            this.eKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E);
            this.eKeyJustPressed = false;

            // Mobile E button (fixed to camera, semi-transparent)
            const eBtnSize = 70;
            this.mobileEBtn = this.add.circle(screenWidth / 2, screenHeight - 150, eBtnSize / 2, 0x4a90d9, 0.7)
                .setScrollFactor(0).setDepth(200).setVisible(false).setInteractive({ useHandCursor: true });
            this.mobileEText = this.add.text(screenWidth / 2, screenHeight - 150, 'E', {
                fontSize: '40px', fontFamily: 'Courier New', color: '#ffffff', fontStyle: 'bold'
            }).setOrigin(0.5).setScrollFactor(0).setDepth(201).setVisible(false);

            this.mobileEBtn.on('pointerdown', () => {
                this.handleInteraction();
            });

            // Disable physics world bounds ‚Äî we handle collision ourselves
            this.player.setCollideWorldBounds(false);
        }

        // Handle E key / mobile E button press
        handleInteraction() {
            const rw = this.roomWidth;
            const rh = this.roomHeight;

            // If an action is currently active, deactivate it
            if (this.activeInteraction) {
                const item = this.activeInteraction;
                if (item.actionSprite) item.actionSprite.setVisible(false);
                else item.lineSprite.setVisible(false);
                item.state = 'idle';
                this.activeInteraction = null;
                return;
            }

            // Find the nearest item that player is close to
            let nearestItem = null;
            let nearestDist = Infinity;

            this.interactiveItems.forEach(item => {
                const cx = item.proximityCenter.x * rw;
                const cy = item.proximityCenter.y * rh;
                const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, cx, cy);
                if (dist < item.proximityRadius && dist < nearestDist) {
                    nearestDist = dist;
                    nearestItem = item;
                }
            });

            if (nearestItem && nearestItem.state === 'near') {
                // Activate action: hide line, show action overlay
                nearestItem.lineSprite.setVisible(false);
                if (nearestItem.actionSprite) {
                    nearestItem.actionSprite.setVisible(true);
                } else {
                    // If no separate action overlay, keep line visible as the "action"
                    nearestItem.lineSprite.setVisible(true);
                }
                nearestItem.state = 'active';
                this.activeInteraction = nearestItem;
                // Stop player movement
                this.player.body.setVelocity(0, 0);
                this.targetX = null;
                this.targetY = null;
            }
        }

        // Point-in-polygon test (ray casting algorithm)
        pointInPolygon(px, py, polygon, rw, rh) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x * rw, yi = polygon[i].y * rh;
                const xj = polygon[j].x * rw, yj = polygon[j].y * rh;
                const intersect = ((yi > py) !== (yj > py)) &&
                    (px < (xj - xi) * (py - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // Check distance from point to a line segment (for green transition)
        pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let t = lenSq !== 0 ? dot / lenSq : -1;
            t = Math.max(0, Math.min(1, t));
            const xx = x1 + t * C;
            const yy = y1 + t * D;
            return Math.sqrt((px - xx) * (px - xx) + (py - yy) * (py - yy));
        }

        update() {
            const moveSpeed = 250;
            const rw = this.roomWidth;
            const rh = this.roomHeight;

            // --- INTERACTION: E key detection (must be at top of update) ---
            if (Phaser.Input.Keyboard.JustDown(this.eKey)) {
                this.handleInteraction();
            }

            // If an action is active, block ALL movement, show mobile E, skip rest
            if (this.activeInteraction) {
                this.player.body.setVelocity(0, 0);
                this.ePrompt.setVisible(false);
                this.mobileEBtn.setVisible(true);
                this.mobileEText.setVisible(true);
                this.player.anims.play('idle-' + this.playerDirection, true);
                return; // Skip all movement, collision, transition logic
            }

            let vx = 0;
            let vy = 0;

            // WASD + arrow keys + virtual buttons
            const left = this.wasd.left.isDown || this.cursors.left.isDown || this.virtualInput.left;
            const right = this.wasd.right.isDown || this.cursors.right.isDown || this.virtualInput.right;
            const up = this.wasd.up.isDown || this.cursors.up.isDown || this.virtualInput.up;
            const down = this.wasd.down.isDown || this.cursors.down.isDown || this.virtualInput.down;

            if (left) vx = -moveSpeed;
            else if (right) vx = moveSpeed;
            if (up) vy = -moveSpeed;
            else if (down) vy = moveSpeed;

            const usingKeyboard = left || right || up || down;

            if (usingKeyboard) {
                this.targetX = null;
                this.targetY = null;
            }

            // Click-to-move: stop when close to target
            if (this.targetX !== null && this.targetY !== null) {
                const distance = Phaser.Math.Distance.Between(
                    this.player.x, this.player.y,
                    this.targetX, this.targetY
                );
                if (distance < 10) {
                    this.targetX = null;
                    this.targetY = null;
                } else {
                    const angle = Math.atan2(this.targetY - this.player.y, this.targetX - this.player.x);
                    vx = Math.cos(angle) * moveSpeed;
                    vy = Math.sin(angle) * moveSpeed;
                }
            }

            // --- POLYGON COLLISION CHECK ---
            const dt = this.game.loop.delta / 1000;
            const nextX = this.player.x + vx * dt;
            const nextY = this.player.y + vy * dt;

            const inOuter = this.pointInPolygon(nextX, nextY, this.walkablePolygon, rw, rh);
            const inOttoman = this.pointInPolygon(nextX, nextY, this.ottomanPolygon, rw, rh);

            if (inOuter && !inOttoman) {
                // Movement is valid
                this.player.body.setVelocity(vx, vy);
            } else {
                // Try sliding: allow X movement only
                const slideX_x = this.player.x + vx * dt;
                const slideX_y = this.player.y;
                const xOk = this.pointInPolygon(slideX_x, slideX_y, this.walkablePolygon, rw, rh)
                          && !this.pointInPolygon(slideX_x, slideX_y, this.ottomanPolygon, rw, rh);

                // Try sliding: allow Y movement only
                const slideY_x = this.player.x;
                const slideY_y = this.player.y + vy * dt;
                const yOk = this.pointInPolygon(slideY_x, slideY_y, this.walkablePolygon, rw, rh)
                          && !this.pointInPolygon(slideY_x, slideY_y, this.ottomanPolygon, rw, rh);

                if (xOk && !yOk) {
                    this.player.body.setVelocity(vx, 0);
                } else if (yOk && !xOk) {
                    this.player.body.setVelocity(0, vy);
                } else {
                    this.player.body.setVelocity(0, 0);
                }
            }

            // If no input and no click target, stop
            if (!usingKeyboard && this.targetX === null) {
                this.player.body.setVelocity(0, 0);
            }

            // --- GREEN LINE TRANSITION CHECK ---
            if (!this.isTransitioning) {
                const dist = this.pointToLineDistance(
                    this.player.x, this.player.y,
                    this.greenLineStart.x * rw, this.greenLineStart.y * rh,
                    this.greenLineEnd.x * rw, this.greenLineEnd.y * rh
                );
                if (dist < 30) {
                    this.isTransitioning = true;
                    this.player.body.setVelocity(0, 0);
                    this.cameras.main.fadeOut(800, 0, 0, 0);
                    this.time.delayedCall(800, () => {
                        this.scene.start('StudioScene', { fromLiving: true });
                    });
                }
            }

            // --- LOCKED DOOR CHECK ---
            if (this.pointInPolygon(this.player.x, this.player.y, this.lockedDoorPoly, rw, rh)) {
                if (this.lockedDoorTimer <= 0) {
                    this.lockedDoorTimer = 2500;
                    this.tweens.add({ targets: this.lockedDoorMessage, alpha: 1, duration: 300 });
                    this.time.delayedCall(2500, () => {
                        this.tweens.add({ targets: this.lockedDoorMessage, alpha: 0, duration: 300 });
                    });
                }
            }
            if (this.lockedDoorTimer > 0) this.lockedDoorTimer -= this.game.loop.delta;

            // --- ANIMATION ---
            const speed = this.player.body.velocity.length();
            if (speed > 10) {
                const angle = Math.atan2(this.player.body.velocity.y, this.player.body.velocity.x);
                const deg = Phaser.Math.RadToDeg(angle);
                if (deg > -45 && deg <= 45) { this.player.anims.play('walk-right', true); this.playerDirection = 'right'; }
                else if (deg > 45 && deg <= 135) { this.player.anims.play('walk-down', true); this.playerDirection = 'down'; }
                else if (deg > 135 || deg <= -135) { this.player.anims.play('walk-left', true); this.playerDirection = 'left'; }
                else { this.player.anims.play('walk-up', true); this.playerDirection = 'up'; }
            } else {
                this.player.anims.play('idle-' + this.playerDirection, true);
            }

            // --- INTERACTION PROXIMITY CHECK ---
            let nearAnyItem = false;
            this.interactiveItems.forEach(item => {
                const cx = item.proximityCenter.x * rw;
                const cy = item.proximityCenter.y * rh;
                const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, cx, cy);

                if (dist < item.proximityRadius && item.state !== 'active') {
                    // Player is near ‚Äî show line overlay
                    if (item.state !== 'near') {
                        item.lineSprite.setVisible(true);
                        item.lineSprite.setAlpha(0);
                        this.tweens.add({ targets: item.lineSprite, alpha: 1, duration: 300 });
                        item.state = 'near';
                    }
                    nearAnyItem = true;
                } else if (item.state === 'near') {
                    // Player walked away ‚Äî hide line overlay
                    this.tweens.add({
                        targets: item.lineSprite, alpha: 0, duration: 200,
                        onComplete: () => { item.lineSprite.setVisible(false); }
                    });
                    item.state = 'idle';
                }
            });

            // DEBUG: Update player dot position + color (green=normal, white=in zone)
            this.debugPlayerDot.setPosition(this.player.x, this.player.y);
            this.debugPlayerDot.setFillStyle(nearAnyItem ? 0xffffff : 0x00ff00, 0.9);

            // Show/hide E prompt and mobile E button
            if (nearAnyItem) {
                this.ePrompt.setPosition(this.player.x, this.player.y - 140);
                this.ePrompt.setVisible(true);
                this.mobileEBtn.setVisible(true);
                this.mobileEText.setVisible(true);
            } else {
                this.ePrompt.setVisible(false);
                this.mobileEBtn.setVisible(false);
                this.mobileEText.setVisible(false);
            }
        }
    }

    // --- –°–¢–£–î–ò–Ø ---
    class StudioScene extends Phaser.Scene {
        constructor() { super('StudioScene'); }

        preload() {
            // Load room based on selected map style
            const style = MAP_STYLES[window.mapStyle] || MAP_STYLES['default'];
            this.load.image('room2', style.room2);

            // --- INTERACTION OVERLAYS for Room 2 (Studio) ---
            // Audio interface + Rick Owens ‚Äî 2048x2048 overlays for studio room
            this.load.image('line_audio_interface', 'action_audio_interface.png');
            this.load.image('line_rick_owens', 'action_rick_owens.png');
        }

        create() {
            const screenWidth = this.scale.width;
            const screenHeight = this.scale.height;

            const bg = this.add.image(0, 0, 'room2').setOrigin(0, 0);

            const scaleX = screenWidth / bg.width;
            const scaleY = screenHeight / bg.height;
            const scale = Math.max(scaleX, scaleY);

            bg.setScale(scale);

            const roomWidth = bg.width * scale;
            const roomHeight = bg.height * scale;

            this.physics.world.setBounds(0, 0, roomWidth, roomHeight);

            // –ü–µ—Ä—Å–æ–Ω–∞–∂ ‚Äî spawn inside walkable isometric floor area
            const fromLiving = this.scene.settings.data?.fromLiving;

            if (fromLiving) {
                // Coming from living room ‚Äî spawn in center of studio floor
                this.player = this.physics.add.sprite(roomWidth * 0.50, roomHeight * 0.70, 'playerSprite');
            } else {
                // First time
                this.player = this.physics.add.sprite(roomWidth * 0.40, roomHeight * 0.80, 'playerSprite');
            }

            this.player.setScale(0.5);
            this.player.setOrigin(0.5, 1);
            this.player.setCollideWorldBounds(true);
            this.player.body.setSize(20, 10);
            this.player.body.setOffset(22, 54);
            this.player.anims.play('idle-down');
            this.playerDirection = 'down';

            // –ö–ê–ú–ï–†–ê + –ó–£–ú
            this.cameras.main.startFollow(this.player, true, 0.1, 0.1);
            this.cameras.main.setBounds(0, 0, roomWidth, roomHeight);
            this.cameras.main.setZoom(1.4);
            this.cameras.main.fadeIn(1000, 0, 0, 0);

            this.targetX = null;
            this.targetY = null;
            this.isTransitioning = false;

            // --- WASD –£–ü–†–ê–í–õ–ï–ù–ò–ï ---
            this.cursors = this.input.keyboard.createCursorKeys();
            this.wasd = this.input.keyboard.addKeys({
                up: Phaser.Input.Keyboard.KeyCodes.W,
                down: Phaser.Input.Keyboard.KeyCodes.S,
                left: Phaser.Input.Keyboard.KeyCodes.A,
                right: Phaser.Input.Keyboard.KeyCodes.D
            });

            // --- –í–ò–†–¢–£–ê–õ–¨–ù–´–ï –°–¢–†–ï–õ–ö–ò (–¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö) ---
            const buttonSize = 80;
            const buttonAlpha = 0.6;
            const buttonColor = 0x444444;

            this.btnLeft = this.add.circle(120, screenHeight - 150, buttonSize/2, buttonColor, buttonAlpha);
            this.btnLeft.setScrollFactor(0).setInteractive();
            this.add.text(120, screenHeight - 150, '‚óÑ', { fontSize: '50px', color: '#ffffff' }).setOrigin(0.5).setScrollFactor(0);

            this.btnRight = this.add.circle(280, screenHeight - 150, buttonSize/2, buttonColor, buttonAlpha);
            this.btnRight.setScrollFactor(0).setInteractive();
            this.add.text(280, screenHeight - 150, '‚ñ∫', { fontSize: '50px', color: '#ffffff' }).setOrigin(0.5).setScrollFactor(0);

            this.btnUp = this.add.circle(screenWidth - 120, screenHeight - 230, buttonSize/2, buttonColor, buttonAlpha);
            this.btnUp.setScrollFactor(0).setInteractive();
            this.add.text(screenWidth - 120, screenHeight - 230, '‚ñ≤', { fontSize: '50px', color: '#ffffff' }).setOrigin(0.5).setScrollFactor(0);

            this.btnDown = this.add.circle(screenWidth - 120, screenHeight - 70, buttonSize/2, buttonColor, buttonAlpha);
            this.btnDown.setScrollFactor(0).setInteractive();
            this.add.text(screenWidth - 120, screenHeight - 70, '‚ñº', { fontSize: '50px', color: '#ffffff' }).setOrigin(0.5).setScrollFactor(0);

            this.virtualInput = { left: false, right: false, up: false, down: false };

            this.btnLeft.on('pointerdown', () => { this.virtualInput.left = true; });
            this.btnLeft.on('pointerup', () => { this.virtualInput.left = false; });
            this.btnLeft.on('pointerout', () => { this.virtualInput.left = false; });
            this.btnRight.on('pointerdown', () => { this.virtualInput.right = true; });
            this.btnRight.on('pointerup', () => { this.virtualInput.right = false; });
            this.btnRight.on('pointerout', () => { this.virtualInput.right = false; });
            this.btnUp.on('pointerdown', () => { this.virtualInput.up = true; });
            this.btnUp.on('pointerup', () => { this.virtualInput.up = false; });
            this.btnUp.on('pointerout', () => { this.virtualInput.up = false; });
            this.btnDown.on('pointerdown', () => { this.virtualInput.down = true; });
            this.btnDown.on('pointerup', () => { this.virtualInput.down = false; });
            this.btnDown.on('pointerout', () => { this.virtualInput.down = false; });

            // –ö–ª–∏–∫ –ø–æ –∫–∞—Ä—Ç–µ
            this.input.on('pointerdown', (pointer) => {
                if (this.isTransitioning) return;
                if (pointer.y > screenHeight - 300) return;

                const worldPoint = this.cameras.main.getWorldPoint(pointer.x, pointer.y);
                this.targetX = worldPoint.x;
                this.targetY = worldPoint.y;
                this.physics.moveToObject(this.player, worldPoint, 250);
            });

            // === ROOM 2 ‚Äî POLYGON-BASED ISOMETRIC COLLISIONS ===
            //
            // Studio room walkable area traced from movement image.
            // The red boundary follows the floor edges between desk, chair, couch, door.
            // The floor is an L-shaped area with furniture blocking certain zones.
            //
            // Key furniture blocking zones:
            //   - Desk + monitors (back-left corner)
            //   - Chair (center-left, in front of desk)
            //   - Shelf (back wall behind desk)
            //   - Couch (right side)
            //   - Plant (back-right corner)
            //
            // Walkable floor = the visible wood floor between all furniture

            // Walkable polygon ‚Äî traces the FLOOR ONLY in isometric view
            // Carefully traced from movement image (room2_movements.png)
            //
            // The red boundary follows the floor edges:
            //   - LEFT side: alongside the door, up to desk/shelf area
            //   - TOP: runs along desk bottom, around chair, along couch back
            //   - RIGHT: runs along couch right arm edge
            //   - BOTTOM: front floor edge
            //
            // The L-shape comes from the desk+chair blocking the upper-left
            // and the couch blocking the upper-right
            //
            // Going clockwise from top-left
            this.walkablePolygon = [
                { x: 0.08, y: 0.72 },  // Door: left corner
                { x: 0.26, y: 0.625 },  // Door + Studio: right corner
                { x: 0.35, y: 0.68 },  // Studio: left corner
                { x: 0.36, y: 0.675 },
				{ x: 0.32, y: 0.63 },  // Top-center: open floor between chair and couch
                { x: 0.38, y: 0.60 },
				{ x: 0.40, y: 0.66 },
				{ x: 0.47, y: 0.70 },
				{ x: 0.53, y: 0.66 },
				{ x: 0.56, y: 0.65 },
				{ x: 0.51, y: 0.61 },
				{ x: 0.53, y: 0.60 },
				{ x: 0.54, y: 0.54 },  // Cupboard: left corner
				{ x: 0.59, y: 0.51 },  // Cupboard: right corner
                { x: 0.645, y: 0.55 },
				{ x: 0.645, y: 0.60 },  // Top-right: floor below couch back
                { x: 0.73, y: 0.66 },  // Right: couch front-right edge
                { x: 0.27, y: 0.84 },  // Bottom-left: left front floor edge
            ];

            // Chair ‚Äî island blocking area (the desk chair in center-left)
            this.chairPolygon = [
                { x: 0.40, y: 0.66 },  // Left
                { x: 0.47, y: 0.60 },  // Top
                { x: 0.54, y: 0.66 },  // Right
                { x: 0.47, y: 0.70 },  // Bottom
            ];

            this.roomWidth = roomWidth;
            this.roomHeight = roomHeight;

            // GREEN TRANSITION LINE ‚Äî diagonal "\" from movement image
            // In the image: green line goes from left side down to right bottom
            // roughly from (0.12, 0.76) to (0.58, 0.92) ‚Äî a "\" diagonal
            this.greenLineStart = { x: 0.26, y: 0.85 };
            this.greenLineEnd = { x: 0.72, y: 0.67 };

            // Locked door zone (left wall ‚Äî near the door)
            this.lockedDoorPoly = [
                { x: 0.04, y: 0.58 },
                { x: 0.14, y: 0.52 },
                { x: 0.14, y: 0.62 },
                { x: 0.04, y: 0.68 },
            ];
            this.lockedDoorMessage = this.add.text(roomWidth * 0.20, roomHeight * 0.45,
                '–ï—â–µ –Ω–µ –≤—Ä–µ–º—è', {
                fontSize: '48px',
                fontFamily: 'Courier New',
                color: '#ffffff',
                backgroundColor: '#000000',
                padding: { x: 25, y: 12 },
                alpha: 0
            }).setOrigin(0.5).setDepth(100);
            this.lockedDoorTimer = 0;

            // DEBUG: Draw the polygons
            const debugGfx = this.add.graphics();
            debugGfx.setDepth(50);

            // Outer walkable polygon (red outline)
            debugGfx.lineStyle(3, 0xff0000, 0.8);
            debugGfx.beginPath();
            this.walkablePolygon.forEach((p, i) => {
                const px = p.x * roomWidth;
                const py = p.y * roomHeight;
                if (i === 0) debugGfx.moveTo(px, py);
                else debugGfx.lineTo(px, py);
            });
            debugGfx.closePath();
            debugGfx.strokePath();

            // Chair polygon (red filled)
            debugGfx.lineStyle(3, 0xff0000, 0.8);
            debugGfx.fillStyle(0xff0000, 0.15);
            debugGfx.beginPath();
            this.chairPolygon.forEach((p, i) => {
                const px = p.x * roomWidth;
                const py = p.y * roomHeight;
                if (i === 0) debugGfx.moveTo(px, py);
                else debugGfx.lineTo(px, py);
            });
            debugGfx.closePath();
            debugGfx.strokePath();
            debugGfx.fillPath();

            // Green transition line
            debugGfx.lineStyle(4, 0x00ff00, 0.8);
            debugGfx.beginPath();
            debugGfx.moveTo(this.greenLineStart.x * roomWidth, this.greenLineStart.y * roomHeight);
            debugGfx.lineTo(this.greenLineEnd.x * roomWidth, this.greenLineEnd.y * roomHeight);
            debugGfx.strokePath();

            // Locked door zone
            debugGfx.lineStyle(2, 0xffff00, 0.6);
            debugGfx.beginPath();
            this.lockedDoorPoly.forEach((p, i) => {
                if (i === 0) debugGfx.moveTo(p.x * roomWidth, p.y * roomHeight);
                else debugGfx.lineTo(p.x * roomWidth, p.y * roomHeight);
            });
            debugGfx.closePath();
            debugGfx.strokePath();

            // === INTERACTION SYSTEM ===
            // Define interactive items for Room 2 (Studio)
            this.interactiveItems = [
                {
                    id: 'audio_interface',
                    // Apollo Twin X ‚Äî on the desk, center-left of studio
                    proximityCenter: { x: 0.35, y: 0.60 },
                    proximityRadius: 90,
                    lineOverlay: 'line_audio_interface',
                    actionOverlay: null,
                },
                {
                    id: 'rick_owens',
                    // Rick Owens ‚Äî on the shelf/cupboard, back wall
                    proximityCenter: { x: 0.60, y: 0.53 },
                    proximityRadius: 90,
                    lineOverlay: 'line_rick_owens',
                    actionOverlay: null,
                },
            ];

            // Create overlay sprites for each item
            this.interactiveItems.forEach(item => {
                // Line/glow overlay ‚Äî shows when player is near
                item.lineSprite = this.add.image(0, 0, item.lineOverlay).setOrigin(0, 0);
                item.lineSprite.setScale(scale);
                item.lineSprite.setVisible(false);
                item.lineSprite.setDepth(10);

                // Action overlay ‚Äî shows when E is pressed
                if (item.actionOverlay) {
                    item.actionSprite = this.add.image(0, 0, item.actionOverlay).setOrigin(0, 0);
                    item.actionSprite.setScale(scale);
                    item.actionSprite.setVisible(false);
                    item.actionSprite.setDepth(10);
                } else {
                    item.actionSprite = null;
                }

                item.state = 'idle';
            });

            // DEBUG: Draw yellow interaction zones
            this.interactiveItems.forEach(item => {
                const cx = item.proximityCenter.x * roomWidth;
                const cy = item.proximityCenter.y * roomHeight;
                debugGfx.lineStyle(2, 0xffff00, 0.8);
                debugGfx.fillStyle(0xffff00, 0.1);
                debugGfx.strokeCircle(cx, cy, item.proximityRadius);
                debugGfx.fillCircle(cx, cy, item.proximityRadius);
                // Label
                const label = this.add.text(cx, cy - item.proximityRadius - 10, item.id, {
                    fontSize: '18px', fontFamily: 'Courier New', color: '#ffff00',
                    stroke: '#000000', strokeThickness: 3
                }).setOrigin(0.5).setDepth(51);
            });

            // DEBUG: Player dot that turns white when in interaction zone
            this.debugPlayerDot = this.add.circle(0, 0, 8, 0x00ff00, 0.9).setDepth(55);

            this.activeInteraction = null;

            // E key prompt
            this.ePrompt = this.add.text(0, 0, '[E]', {
                fontSize: '36px',
                fontFamily: 'Courier New',
                color: '#ffffff',
                backgroundColor: '#000000aa',
                padding: { x: 12, y: 6 },
                fontStyle: 'bold'
            }).setOrigin(0.5).setDepth(150).setVisible(false);

            this.tweens.add({
                targets: this.ePrompt,
                alpha: { from: 0.6, to: 1 },
                scaleX: { from: 0.95, to: 1.05 },
                scaleY: { from: 0.95, to: 1.05 },
                duration: 800,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });

            // E key input
            this.eKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E);

            // Mobile E button
            const eBtnSize = 70;
            this.mobileEBtn = this.add.circle(screenWidth / 2, screenHeight - 150, eBtnSize / 2, 0x4a90d9, 0.7)
                .setScrollFactor(0).setDepth(200).setVisible(false).setInteractive({ useHandCursor: true });
            this.mobileEText = this.add.text(screenWidth / 2, screenHeight - 150, 'E', {
                fontSize: '40px', fontFamily: 'Courier New', color: '#ffffff', fontStyle: 'bold'
            }).setOrigin(0.5).setScrollFactor(0).setDepth(201).setVisible(false);

            this.mobileEBtn.on('pointerdown', () => {
                this.handleInteraction();
            });

            // Disable physics world bounds ‚Äî we handle collision ourselves
            this.player.setCollideWorldBounds(false);
        }

        // Handle E key / mobile E button press
        handleInteraction() {
            const rw = this.roomWidth;
            const rh = this.roomHeight;

            // If an action is currently active, deactivate it
            if (this.activeInteraction) {
                const item = this.activeInteraction;
                if (item.actionSprite) item.actionSprite.setVisible(false);
                else item.lineSprite.setVisible(false);
                item.state = 'idle';
                this.activeInteraction = null;
                return;
            }

            // Find the nearest item that player is close to
            let nearestItem = null;
            let nearestDist = Infinity;

            this.interactiveItems.forEach(item => {
                const cx = item.proximityCenter.x * rw;
                const cy = item.proximityCenter.y * rh;
                const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, cx, cy);
                if (dist < item.proximityRadius && dist < nearestDist) {
                    nearestDist = dist;
                    nearestItem = item;
                }
            });

            if (nearestItem && nearestItem.state === 'near') {
                nearestItem.lineSprite.setVisible(false);
                if (nearestItem.actionSprite) {
                    nearestItem.actionSprite.setVisible(true);
                } else {
                    nearestItem.lineSprite.setVisible(true);
                }
                nearestItem.state = 'active';
                this.activeInteraction = nearestItem;
                this.player.body.setVelocity(0, 0);
                this.targetX = null;
                this.targetY = null;
            }
        }

        // Point-in-polygon test (ray casting algorithm)
        pointInPolygon(px, py, polygon, rw, rh) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x * rw, yi = polygon[i].y * rh;
                const xj = polygon[j].x * rw, yj = polygon[j].y * rh;
                const intersect = ((yi > py) !== (yj > py)) &&
                    (px < (xj - xi) * (py - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let t = lenSq !== 0 ? dot / lenSq : -1;
            t = Math.max(0, Math.min(1, t));
            const xx = x1 + t * C, yy = y1 + t * D;
            return Math.sqrt((px - xx) * (px - xx) + (py - yy) * (py - yy));
        }

        update() {
            const moveSpeed = 250;
            const rw = this.roomWidth;
            const rh = this.roomHeight;

            // --- INTERACTION: E key detection (must be at top of update) ---
            if (Phaser.Input.Keyboard.JustDown(this.eKey)) {
                this.handleInteraction();
            }

            // If an action is active, block ALL movement, show mobile E, skip rest
            if (this.activeInteraction) {
                this.player.body.setVelocity(0, 0);
                this.ePrompt.setVisible(false);
                this.mobileEBtn.setVisible(true);
                this.mobileEText.setVisible(true);
                this.player.anims.play('idle-' + this.playerDirection, true);
                return; // Skip all movement, collision, transition logic
            }

            let vx = 0;
            let vy = 0;

            const left = this.wasd.left.isDown || this.cursors.left.isDown || this.virtualInput.left;
            const right = this.wasd.right.isDown || this.cursors.right.isDown || this.virtualInput.right;
            const up = this.wasd.up.isDown || this.cursors.up.isDown || this.virtualInput.up;
            const down = this.wasd.down.isDown || this.cursors.down.isDown || this.virtualInput.down;

            if (left) vx = -moveSpeed;
            else if (right) vx = moveSpeed;
            if (up) vy = -moveSpeed;
            else if (down) vy = moveSpeed;

            const usingKeyboard = left || right || up || down;

            if (usingKeyboard) {
                this.targetX = null;
                this.targetY = null;
            }

            if (this.targetX !== null && this.targetY !== null) {
                const distance = Phaser.Math.Distance.Between(
                    this.player.x, this.player.y, this.targetX, this.targetY
                );
                if (distance < 10) {
                    this.targetX = null;
                    this.targetY = null;
                } else {
                    const angle = Math.atan2(this.targetY - this.player.y, this.targetX - this.player.x);
                    vx = Math.cos(angle) * moveSpeed;
                    vy = Math.sin(angle) * moveSpeed;
                }
            }

            // --- POLYGON COLLISION CHECK ---
            const dt = this.game.loop.delta / 1000;
            const nextX = this.player.x + vx * dt;
            const nextY = this.player.y + vy * dt;

            const inOuter = this.pointInPolygon(nextX, nextY, this.walkablePolygon, rw, rh);
            const inChair = this.pointInPolygon(nextX, nextY, this.chairPolygon, rw, rh);

            if (inOuter && !inChair) {
                this.player.body.setVelocity(vx, vy);
            } else {
                const slideX_x = this.player.x + vx * dt;
                const slideX_y = this.player.y;
                const xOk = this.pointInPolygon(slideX_x, slideX_y, this.walkablePolygon, rw, rh)
                          && !this.pointInPolygon(slideX_x, slideX_y, this.chairPolygon, rw, rh);

                const slideY_x = this.player.x;
                const slideY_y = this.player.y + vy * dt;
                const yOk = this.pointInPolygon(slideY_x, slideY_y, this.walkablePolygon, rw, rh)
                          && !this.pointInPolygon(slideY_x, slideY_y, this.chairPolygon, rw, rh);

                if (xOk && !yOk) this.player.body.setVelocity(vx, 0);
                else if (yOk && !xOk) this.player.body.setVelocity(0, vy);
                else this.player.body.setVelocity(0, 0);
            }

            if (!usingKeyboard && this.targetX === null) {
                this.player.body.setVelocity(0, 0);
            }

            // --- GREEN LINE TRANSITION CHECK ---
            if (!this.isTransitioning) {
                const dist = this.pointToLineDistance(
                    this.player.x, this.player.y,
                    this.greenLineStart.x * rw, this.greenLineStart.y * rh,
                    this.greenLineEnd.x * rw, this.greenLineEnd.y * rh
                );
                if (dist < 30) {
                    this.isTransitioning = true;
                    this.player.body.setVelocity(0, 0);
                    this.cameras.main.fadeOut(800, 0, 0, 0);
                    this.time.delayedCall(800, () => {
                        this.scene.start('MainScene', { fromStudio: true });
                    });
                }
            }

            // --- LOCKED DOOR CHECK ---
            if (this.pointInPolygon(this.player.x, this.player.y, this.lockedDoorPoly, rw, rh)) {
                if (this.lockedDoorTimer <= 0) {
                    this.lockedDoorTimer = 2500;
                    this.tweens.add({ targets: this.lockedDoorMessage, alpha: 1, duration: 300 });
                    this.time.delayedCall(2500, () => {
                        this.tweens.add({ targets: this.lockedDoorMessage, alpha: 0, duration: 300 });
                    });
                }
            }
            if (this.lockedDoorTimer > 0) this.lockedDoorTimer -= this.game.loop.delta;

            // --- ANIMATION ---
            const speed = this.player.body.velocity.length();
            if (speed > 10) {
                const angle = Math.atan2(this.player.body.velocity.y, this.player.body.velocity.x);
                const deg = Phaser.Math.RadToDeg(angle);
                if (deg > -45 && deg <= 45) { this.player.anims.play('walk-right', true); this.playerDirection = 'right'; }
                else if (deg > 45 && deg <= 135) { this.player.anims.play('walk-down', true); this.playerDirection = 'down'; }
                else if (deg > 135 || deg <= -135) { this.player.anims.play('walk-left', true); this.playerDirection = 'left'; }
                else { this.player.anims.play('walk-up', true); this.playerDirection = 'up'; }
            } else {
                this.player.anims.play('idle-' + this.playerDirection, true);
            }

            // --- INTERACTION PROXIMITY CHECK ---
            let nearAnyItem = false;
            this.interactiveItems.forEach(item => {
                const cx = item.proximityCenter.x * rw;
                const cy = item.proximityCenter.y * rh;
                const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, cx, cy);

                if (dist < item.proximityRadius && item.state !== 'active') {
                    if (item.state !== 'near') {
                        item.lineSprite.setVisible(true);
                        item.lineSprite.setAlpha(0);
                        this.tweens.add({ targets: item.lineSprite, alpha: 1, duration: 300 });
                        item.state = 'near';
                    }
                    nearAnyItem = true;
                } else if (item.state === 'near') {
                    this.tweens.add({
                        targets: item.lineSprite, alpha: 0, duration: 200,
                        onComplete: () => { item.lineSprite.setVisible(false); }
                    });
                    item.state = 'idle';
                }
            });

            // DEBUG: Update player dot position + color (green=normal, white=in zone)
            this.debugPlayerDot.setPosition(this.player.x, this.player.y);
            this.debugPlayerDot.setFillStyle(nearAnyItem ? 0xffffff : 0x00ff00, 0.9);

            // Show/hide E prompt and mobile E button
            if (nearAnyItem) {
                this.ePrompt.setPosition(this.player.x, this.player.y - 140);
                this.ePrompt.setVisible(true);
                this.mobileEBtn.setVisible(true);
                this.mobileEText.setVisible(true);
            } else {
                this.ePrompt.setVisible(false);
                this.mobileEBtn.setVisible(false);
                this.mobileEText.setVisible(false);
            }
        }
    }

    // --- –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø ---
    const config = {
        type: Phaser.AUTO,
        backgroundColor: 'transparent', // –í–ê–ñ–ù–û: –ø—Ä–æ–∑—Ä–∞—á–Ω—ã–π —Ñ–æ–Ω –¥–ª—è Canvas
        scale: {
            mode: Phaser.Scale.FIT,
            autoCenter: Phaser.Scale.CENTER_BOTH,
            width: 1080,
            height: 1920
        },
        physics: {
            default: 'arcade',
            arcade: {
                debug: true,
                gravity: { y: 0 }
            }
        },
        render: {
            antialias: false,  // –û—Ç–∫–ª—é—á–∞–µ–º –∞–Ω—Ç–∏–∞–ª–∏–∞—Å–∏–Ω–≥ –¥–ª—è –ø–∏–∫—Å–µ–ª—å-–∞—Ä—Ç–∞
            pixelArt: true,    // –ö–†–ò–¢–ò–ß–ù–û: –≤–∫–ª—é—á–∞–µ–º —Ä–µ–∂–∏–º –ø–∏–∫—Å–µ–ª—å-–∞—Ä—Ç–∞
            transparent: true  // –ü—Ä–æ–∑—Ä–∞—á–Ω–æ—Å—Ç—å
        },
        scene: [MenuScene, MainScene, StudioScene]
    };

    const game = new Phaser.Game(config);
</script>
</body>
</html>