<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>WERYPEAS</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        canvas { display: block; }
    </style>
</head>
<body>
<script>
    // --- GLOBAL MAP STYLE ---
    // 'default', 'realistic', or 'anime'
    window.mapStyle = 'default';

    // --- GLOBAL STATE (persists across scenes) ---
    window.activeAudio = null; // { itemId, soundKey, sound } or null
    window.activeItems = {};   // { itemId: true } â€” tracks all active interactions (with or without sound)
    window.roomLightMode = 'default'; // 'default' | 'blue' | 'pink' | 'green'
    window.tvGameMode = 'off'; // 'off' | 'fortnite' | 'mortal_kombat' | 'naruto'

    // Light mode cycle order
    const LIGHT_MODES = ['default', 'blue', 'pink', 'green'];

    // TV game cycle order
    const TV_GAMES = ['off', 'fortnite', 'mortal_kombat', 'naruto'];
    // Maps game mode to texture key
    const TV_GAME_TEXTURES = {
        'fortnite': 'tv_fortnite',
        'mortal_kombat': 'tv_mortal_kombat',
        'naruto': 'tv_naruto',
    };

    // Room image filenames per light mode (per map style)
    const ROOM_LIGHT_IMAGES = {
        'default': { room1: 'assets/default/room1.png',       room2: 'assets/default/room2.png' },
        'blue':    { room1: 'assets/default/room1_blue.png',   room2: 'assets/default/room2_blue.png' },
        'pink':    { room1: 'assets/default/room1_pink.png',   room2: 'assets/default/room2_pink.png' },
        'green':   { room1: 'assets/default/room1_green.png',  room2: 'assets/default/room2_green.png' },
    };

    // Map style to room image filenames
    const MAP_STYLES = {
        'default':   { room1: 'assets/default/room1.png',           room2: 'assets/default/room2.png' },
        'realistic': { room1: 'assets/default/room1_realistic.png',  room2: 'assets/default/room2_realistic.png' },
        'anime':     { room1: 'assets/default/room1_anime.png',      room2: 'assets/default/room2_anime.png' },
    };

    // --- START MENU SCENE ---
    class MenuScene extends Phaser.Scene {
        constructor() { super('MenuScene'); }

        preload() {
            this.load.image('menuBg', '/assets/menu_bg.jpg');
            this.load.image('menuUI', '/assets/menu.png');

            this.load.on('loaderror', (file) => {
                console.error('ÐžÑˆÐ¸Ð±ÐºÐ° Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸: ' + file.key);
            });
        }

        create() {
            const { width, height } = this.scale;

            // Full-screen studio artwork background
            const bg = this.add.image(width / 2, height / 2, 'menuBg');
            const bgScaleX = width / bg.width;
            const bgScaleY = height / bg.height;
            const bgScale = Math.max(bgScaleX, bgScaleY);
            bg.setScale(bgScale);

            // Dark overlay â€” subtle, let the artwork show through
            const overlay = this.add.graphics();
            overlay.fillStyle(0x000000, 0.3);
            overlay.fillRect(0, 0, width, height);

            // --- PIXEL-ART MENU BOX (transparent) ---
            const boxW = 620;
            const boxH = 380;
            const boxX = width / 2 - boxW / 2;
            const boxY = height / 2 - boxH / 2 - 60;

            const menuBox = this.add.graphics();
            menuBox.fillStyle(0x6b7a8d, 0.5);
            menuBox.fillRect(boxX - 6, boxY - 6, boxW + 12, boxH + 12);
            menuBox.fillStyle(0x4a5568, 0.5);
            menuBox.fillRect(boxX - 3, boxY - 3, boxW + 6, boxH + 6);
            menuBox.fillStyle(0x2d3748, 0.55);
            menuBox.fillRect(boxX, boxY, boxW, boxH);
            menuBox.fillStyle(0x4a5568, 0.4);
            menuBox.fillRect(boxX + 4, boxY + 4, boxW - 8, 2);
            menuBox.fillStyle(0x1a202c, 0.4);
            menuBox.fillRect(boxX + 4, boxY + boxH - 6, boxW - 8, 2);

            const title = this.add.text(width / 2, boxY + 75, 'WERYPEAS', {
                fontSize: '64px',
                fontFamily: 'Courier New, monospace',
                color: '#e2e8f0',
                fontStyle: 'bold',
                stroke: '#000000',
                strokeThickness: 8,
                align: 'center'
            }).setOrigin(0.5);

            this.tweens.add({
                targets: title,
                alpha: { from: 0.85, to: 1 },
                duration: 2000,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });

            const btnW = 380;
            const btnH = 60;

            this.createMenuButton(width / 2, boxY + 175, btnW, btnH, 'START GAME', () => {
                this.cameras.main.fadeOut(500, 0, 0, 0);
                this.time.delayedCall(500, () => {
                    this.scene.start('MainScene');
                });
            });

            this.createMenuButton(width / 2, boxY + 260, btnW, btnH, 'OPTIONS', () => {
                this.showOptionsPanel(width, height);
            });

            this.optionsContainer = this.add.container(0, 0).setVisible(false).setDepth(200);

            this.cameras.main.fadeIn(800, 0, 0, 0);
        }

        showOptionsPanel(width, height) {
            if (this.optionsContainer.visible) {
                this.optionsContainer.setVisible(false);
                return;
            }

            this.optionsContainer.removeAll(true);

            const dimBg = this.add.rectangle(width / 2, height / 2, width, height, 0x000000, 0.5)
                .setInteractive();
            this.optionsContainer.add(dimBg);

            const panelW = 560;
            const panelH = 420;
            const px = width / 2 - panelW / 2;
            const py = height / 2 - panelH / 2;

            const panelGfx = this.add.graphics();
            panelGfx.fillStyle(0x6b7a8d, 0.6);
            panelGfx.fillRect(px - 6, py - 6, panelW + 12, panelH + 12);
            panelGfx.fillStyle(0x4a5568, 0.6);
            panelGfx.fillRect(px - 3, py - 3, panelW + 6, panelH + 6);
            panelGfx.fillStyle(0x1a202c, 0.9);
            panelGfx.fillRect(px, py, panelW, panelH);
            this.optionsContainer.add(panelGfx);

            const optTitle = this.add.text(width / 2, py + 45, 'MAP STYLE', {
                fontSize: '40px',
                fontFamily: 'Courier New',
                color: '#e2e8f0',
                fontStyle: 'bold',
                stroke: '#000000',
                strokeThickness: 4
            }).setOrigin(0.5);
            this.optionsContainer.add(optTitle);

            const styles = [
                { key: 'default',   label: 'DEFAULT',   desc: 'Pixel art rooms' },
                { key: 'realistic', label: 'REALISTIC',  desc: 'Realistic style rooms' },
                { key: 'anime',     label: 'ANIME',      desc: 'Anime style rooms' },
            ];

            const optBtnW = 440;
            const optBtnH = 70;
            const startY = py + 110;

            styles.forEach((style, i) => {
                const by = startY + i * 90;
                const isSelected = window.mapStyle === style.key;

                const sBtnGfx = this.add.graphics();
                sBtnGfx.fillStyle(isSelected ? 0x48bb78 : 0x6b7a8d, 0.6);
                sBtnGfx.fillRect(width/2 - optBtnW/2 - 3, by - 3, optBtnW + 6, optBtnH + 6);
                sBtnGfx.fillStyle(isSelected ? 0x2f855a : 0x2d3748, isSelected ? 0.7 : 0.6);
                sBtnGfx.fillRect(width/2 - optBtnW/2, by, optBtnW, optBtnH);
                this.optionsContainer.add(sBtnGfx);

                const marker = this.add.text(width/2 - optBtnW/2 + 30, by + optBtnH/2, isSelected ? '>' : ' ', {
                    fontSize: '32px', fontFamily: 'Courier New',
                    color: isSelected ? '#48bb78' : '#64748b', fontStyle: 'bold'
                }).setOrigin(0.5);
                this.optionsContainer.add(marker);

                const sLabel = this.add.text(width/2 - 20, by + optBtnH/2 - 8, style.label, {
                    fontSize: '32px', fontFamily: 'Courier New',
                    color: isSelected ? '#ffffff' : '#cbd5e1',
                    fontStyle: 'bold', stroke: '#000000', strokeThickness: 2
                }).setOrigin(0.5);
                this.optionsContainer.add(sLabel);

                const sDesc = this.add.text(width/2 - 20, by + optBtnH/2 + 18, style.desc, {
                    fontSize: '20px', fontFamily: 'Courier New',
                    color: isSelected ? '#c6f6d5' : '#94a3b8',
                }).setOrigin(0.5);
                this.optionsContainer.add(sDesc);

                const sHit = this.add.rectangle(width/2, by + optBtnH/2, optBtnW, optBtnH, 0x000000, 0)
                    .setInteractive({ useHandCursor: true });
                this.optionsContainer.add(sHit);

                sHit.on('pointerover', () => {
                    if (window.mapStyle !== style.key) {
                        sBtnGfx.clear();
                        sBtnGfx.fillStyle(0x8a9bb0, 0.6);
                        sBtnGfx.fillRect(width/2 - optBtnW/2 - 3, by - 3, optBtnW + 6, optBtnH + 6);
                        sBtnGfx.fillStyle(0x3d4a5c, 0.7);
                        sBtnGfx.fillRect(width/2 - optBtnW/2, by, optBtnW, optBtnH);
                    }
                });

                sHit.on('pointerout', () => {
                    if (window.mapStyle !== style.key) {
                        sBtnGfx.clear();
                        sBtnGfx.fillStyle(0x6b7a8d, 0.6);
                        sBtnGfx.fillRect(width/2 - optBtnW/2 - 3, by - 3, optBtnW + 6, optBtnH + 6);
                        sBtnGfx.fillStyle(0x2d3748, 0.6);
                        sBtnGfx.fillRect(width/2 - optBtnW/2, by, optBtnW, optBtnH);
                    }
                });

                sHit.on('pointerdown', () => {
                    window.mapStyle = style.key;
                    this.showOptionsPanel(width, height);
                });
            });

            const backY = startY + 3 * 90 + 10;
            const backGfx = this.add.graphics();
            backGfx.fillStyle(0x6b7a8d, 0.5);
            backGfx.fillRect(width/2 - 100 - 3, backY - 3, 206, 52);
            backGfx.fillStyle(0x4a5568, 0.6);
            backGfx.fillRect(width/2 - 100, backY, 200, 46);
            this.optionsContainer.add(backGfx);

            const backText = this.add.text(width / 2, backY + 23, 'BACK', {
                fontSize: '30px', fontFamily: 'Courier New', color: '#e2e8f0',
                fontStyle: 'bold', stroke: '#000000', strokeThickness: 2
            }).setOrigin(0.5);
            this.optionsContainer.add(backText);

            const backHit = this.add.rectangle(width/2, backY + 23, 200, 46, 0x000000, 0)
                .setInteractive({ useHandCursor: true });
            this.optionsContainer.add(backHit);

            backHit.on('pointerdown', () => {
                this.optionsContainer.setVisible(false);
            });

            this.optionsContainer.setVisible(true);
        }

        createMenuButton(x, y, w, h, text, callback) {
            const btnGfx = this.add.graphics();
            btnGfx.fillStyle(0x8a9bb0, 0.5);
            btnGfx.fillRect(x - w/2 - 4, y - h/2 - 4, w + 8, h + 8);
            btnGfx.fillStyle(0x5a6b7d, 0.5);
            btnGfx.fillRect(x - w/2 - 2, y - h/2 - 2, w + 4, h + 4);
            btnGfx.fillStyle(0x4a5568, 0.55);
            btnGfx.fillRect(x - w/2, y - h/2, w, h);
            btnGfx.fillStyle(0x5a6b7d, 0.4);
            btnGfx.fillRect(x - w/2 + 3, y - h/2 + 3, w - 6, 2);

            const hitArea = this.add.rectangle(x, y, w, h, 0x000000, 0)
                .setInteractive({ useHandCursor: true });

            const btnText = this.add.text(x, y, text, {
                fontSize: '36px', fontFamily: 'Courier New', color: '#e2e8f0',
                fontStyle: 'bold', stroke: '#000000', strokeThickness: 3
            }).setOrigin(0.5);

            hitArea.on('pointerover', () => {
                btnGfx.clear();
                btnGfx.fillStyle(0x8a9bb0, 0.6);
                btnGfx.fillRect(x - w/2 - 4, y - h/2 - 4, w + 8, h + 8);
                btnGfx.fillStyle(0x5a6b7d, 0.6);
                btnGfx.fillRect(x - w/2 - 2, y - h/2 - 2, w + 4, h + 4);
                btnGfx.fillStyle(0x5a6b7d, 0.65);
                btnGfx.fillRect(x - w/2, y - h/2, w, h);
                btnGfx.fillStyle(0x6b7d8f, 0.5);
                btnGfx.fillRect(x - w/2 + 3, y - h/2 + 3, w - 6, 2);
                btnText.setColor('#ffffff');
            });

            hitArea.on('pointerout', () => {
                btnGfx.clear();
                btnGfx.fillStyle(0x8a9bb0, 0.5);
                btnGfx.fillRect(x - w/2 - 4, y - h/2 - 4, w + 8, h + 8);
                btnGfx.fillStyle(0x5a6b7d, 0.5);
                btnGfx.fillRect(x - w/2 - 2, y - h/2 - 2, w + 4, h + 4);
                btnGfx.fillStyle(0x4a5568, 0.55);
                btnGfx.fillRect(x - w/2, y - h/2, w, h);
                btnGfx.fillStyle(0x5a6b7d, 0.4);
                btnGfx.fillRect(x - w/2 + 3, y - h/2 + 3, w - 6, 2);
                btnText.setColor('#e2e8f0');
            });

            hitArea.on('pointerdown', () => {
                this.tweens.add({
                    targets: [btnGfx, hitArea, btnText],
                    scale: 0.95,
                    duration: 80,
                    yoyo: true,
                    onComplete: callback
                });
            });
        }
    }

    // --- Ð“Ð›ÐÐ’ÐÐÐ¯ Ð¡Ð¦Ð•ÐÐ (Ð“ÐžÐ¡Ð¢Ð˜ÐÐÐ¯) ---
    class MainScene extends Phaser.Scene {
        constructor() { super('MainScene'); }

        preload() {
            console.log('ðŸ”„ ÐÐ°Ñ‡Ð¸Ð½Ð°ÐµÐ¼ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÑƒ Ñ€ÐµÑÑƒÑ€ÑÐ¾Ð²...');

            const style = MAP_STYLES[window.mapStyle] || MAP_STYLES['default'];
            this.load.image('room1', style.room1);

            this.load.spritesheet('playerSprite', '/assets/default/person.png', {
                frameWidth: 512,
                frameHeight: 512
            });

            // --- INTERACTION OVERLAYS for Room 1 (Living Room) ---
            this.load.image('line_guitar', '/assets/interaction/action_guitar.png');
            this.load.image('line_ps_controller', '/assets/interaction/action_ps_controller.png');
            // TV game overlays (cycle through with E)
            this.load.image('tv_fortnite', '/assets/interaction/action_ps_controller_tv_fortnite.png');
            this.load.image('tv_mortal_kombat', '/assets/interaction/action_ps_controller_tv_mortal_kombat.png');
            this.load.image('tv_naruto', '/assets/interaction/action_ps_controller_tv_naruto.png');

            // --- LIGHT VARIANTS for Room 1 ---
            this.load.image('room1_blue', '/assets/default/room1_blue.png');
            this.load.image('room1_pink', '/assets/default/room1_pink.png');
            this.load.image('room1_green', '/assets/default/room1_green.png');

            // --- AUDIO for interactions (load all so they persist across scenes) ---
            this.load.audio('sound_guitar', '/assets/sound/sound_guitar.mp3');
            this.load.audio('sound_audio_interface', '/assets/sound/sound_audio_interface.mp3');

            this.load.on('loaderror', (file) => {
                console.error('âŒ ÐžÐ¨Ð˜Ð‘ÐšÐ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸ Ñ„Ð°Ð¹Ð»Ð°: ' + file.key);
                console.error('âŒ ÐŸÑƒÑ‚ÑŒ Ðº Ñ„Ð°Ð¹Ð»Ñƒ:', file.url);
            });

            this.load.on('complete', () => {
                console.log('âœ… Ð’ÑÐµ Ñ„Ð°Ð¹Ð»Ñ‹ Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ñ‹! Style:', window.mapStyle);
            });
        }

        create() {
            const screenWidth = this.scale.width;
            const screenHeight = this.scale.height;

            // Determine which room1 texture to use based on current light mode
            const lightMode = window.roomLightMode || 'default';
            const room1Key = lightMode === 'default' ? 'room1' : ('room1_' + lightMode);
            const bg = this.add.image(0, 0, room1Key).setOrigin(0, 0);
            this.bg = bg; // store reference for texture swapping

            const scaleX = screenWidth / bg.width;
            const scaleY = screenHeight / bg.height;
            const scale = Math.max(scaleX, scaleY);

            bg.setScale(scale);

            const roomWidth = bg.width * scale;
            const roomHeight = bg.height * scale;

            this.physics.world.setBounds(0, 0, roomWidth, roomHeight);

            if (!this.anims.exists('walk-down')) {
                this.anims.create({ key: 'walk-down', frames: this.anims.generateFrameNumbers('playerSprite', { start: 0, end: 3 }), frameRate: 8, repeat: -1 });
                this.anims.create({ key: 'walk-left', frames: this.anims.generateFrameNumbers('playerSprite', { start: 4, end: 7 }), frameRate: 8, repeat: -1 });
                this.anims.create({ key: 'walk-up', frames: this.anims.generateFrameNumbers('playerSprite', { start: 8, end: 11 }), frameRate: 8, repeat: -1 });
                this.anims.create({ key: 'walk-right', frames: this.anims.generateFrameNumbers('playerSprite', { start: 12, end: 15 }), frameRate: 8, repeat: -1 });
                this.anims.create({ key: 'idle-down', frames: [{ key: 'playerSprite', frame: 0 }] });
                this.anims.create({ key: 'idle-left', frames: [{ key: 'playerSprite', frame: 4 }] });
                this.anims.create({ key: 'idle-up', frames: [{ key: 'playerSprite', frame: 8 }] });
                this.anims.create({ key: 'idle-right', frames: [{ key: 'playerSprite', frame: 12 }] });
            }

            const fromStudio = this.scene.settings.data?.fromStudio;
            if (fromStudio) {
                this.player = this.physics.add.sprite(roomWidth * 0.50, roomHeight * 0.72, 'playerSprite');
            } else {
                this.player = this.physics.add.sprite(roomWidth * 0.55, roomHeight * 0.75, 'playerSprite');
            }

            this.player.setScale(0.7);
            this.player.setOrigin(0.5, 1);
            this.player.setCollideWorldBounds(true);
            this.player.body.setSize(20, 10);
            this.player.body.setOffset(22, 54);
            this.player.anims.play('idle-down');
            this.playerDirection = 'down';

            this.cameras.main.startFollow(this.player, true, 0.1, 0.1);
            this.cameras.main.setBounds(0, 0, roomWidth, roomHeight);
            this.cameras.main.setZoom(1.4);

            this.targetX = null;
            this.targetY = null;
            this.isTransitioning = false;

            this.cursors = this.input.keyboard.createCursorKeys();
            this.wasd = this.input.keyboard.addKeys({
                up: Phaser.Input.Keyboard.KeyCodes.W, down: Phaser.Input.Keyboard.KeyCodes.S,
                left: Phaser.Input.Keyboard.KeyCodes.A, right: Phaser.Input.Keyboard.KeyCodes.D
            });

            const buttonSize = 80;
            const buttonAlpha = 0.6;
            const buttonColor = 0x444444;

            this.btnLeft = this.add.circle(120, screenHeight - 150, buttonSize/2, buttonColor, buttonAlpha);
            this.btnLeft.setScrollFactor(0).setInteractive();
            this.add.text(120, screenHeight - 150, 'â—„', { fontSize: '50px', color: '#ffffff' }).setOrigin(0.5).setScrollFactor(0);
            this.btnRight = this.add.circle(280, screenHeight - 150, buttonSize/2, buttonColor, buttonAlpha);
            this.btnRight.setScrollFactor(0).setInteractive();
            this.add.text(280, screenHeight - 150, 'â–º', { fontSize: '50px', color: '#ffffff' }).setOrigin(0.5).setScrollFactor(0);
            this.btnUp = this.add.circle(screenWidth - 120, screenHeight - 230, buttonSize/2, buttonColor, buttonAlpha);
            this.btnUp.setScrollFactor(0).setInteractive();
            this.add.text(screenWidth - 120, screenHeight - 230, 'â–²', { fontSize: '50px', color: '#ffffff' }).setOrigin(0.5).setScrollFactor(0);
            this.btnDown = this.add.circle(screenWidth - 120, screenHeight - 70, buttonSize/2, buttonColor, buttonAlpha);
            this.btnDown.setScrollFactor(0).setInteractive();
            this.add.text(screenWidth - 120, screenHeight - 70, 'â–¼', { fontSize: '50px', color: '#ffffff' }).setOrigin(0.5).setScrollFactor(0);

            this.virtualInput = { left: false, right: false, up: false, down: false };
            this.btnLeft.on('pointerdown', () => { this.virtualInput.left = true; });
            this.btnLeft.on('pointerup', () => { this.virtualInput.left = false; });
            this.btnLeft.on('pointerout', () => { this.virtualInput.left = false; });
            this.btnRight.on('pointerdown', () => { this.virtualInput.right = true; });
            this.btnRight.on('pointerup', () => { this.virtualInput.right = false; });
            this.btnRight.on('pointerout', () => { this.virtualInput.right = false; });
            this.btnUp.on('pointerdown', () => { this.virtualInput.up = true; });
            this.btnUp.on('pointerup', () => { this.virtualInput.up = false; });
            this.btnUp.on('pointerout', () => { this.virtualInput.up = false; });
            this.btnDown.on('pointerdown', () => { this.virtualInput.down = true; });
            this.btnDown.on('pointerup', () => { this.virtualInput.down = false; });
            this.btnDown.on('pointerout', () => { this.virtualInput.down = false; });

            this.input.on('pointerdown', (pointer) => {
                if (this.isTransitioning) return;
                if (pointer.y > screenHeight - 300) return;
                const worldPoint = this.cameras.main.getWorldPoint(pointer.x, pointer.y);
                this.targetX = worldPoint.x;
                this.targetY = worldPoint.y;
                this.physics.moveToObject(this.player, worldPoint, 250);
            });

            this.walkablePolygon = [
                { x: 0.20, y: 0.60 }, { x: 0.44, y: 0.48 }, { x: 0.67, y: 0.60 },
                { x: 0.74, y: 0.57 }, { x: 0.90, y: 0.65 }, { x: 0.50, y: 0.80 },
                { x: 0.485, y: 0.70 }, { x: 0.46, y: 0.695 }, { x: 0.43, y: 0.71 },
            ];
            this.ottomanPolygon = [
                { x: 0.32, y: 0.60 }, { x: 0.41, y: 0.56 },
                { x: 0.50, y: 0.60 }, { x: 0.41, y: 0.65 },
            ];

            this.roomWidth = roomWidth;
            this.roomHeight = roomHeight;
            this.greenLineStart = { x: 0.50, y: 0.80 };
            this.greenLineEnd = { x: 0.90, y: 0.65 };

            this.lockedDoorPoly = [
                { x: 0.74, y: 0.48 }, { x: 0.86, y: 0.52 },
                { x: 0.86, y: 0.62 }, { x: 0.74, y: 0.58 },
            ];
            this.lockedDoorMessage = this.add.text(roomWidth * 0.75, roomHeight * 0.35,
                'Ð•Ñ‰Ðµ Ð½Ðµ Ð²Ñ€ÐµÐ¼Ñ', {
                fontSize: '48px', fontFamily: 'Courier New', color: '#ffffff',
                backgroundColor: '#000000', padding: { x: 25, y: 12 }, alpha: 0
            }).setOrigin(0.5).setDepth(100);
            this.lockedDoorTimer = 0;

            // DEBUG: Draw the polygons
            const debugGfx = this.add.graphics();
            debugGfx.setDepth(50);

            debugGfx.lineStyle(3, 0xff0000, 0.8);
            debugGfx.beginPath();
            this.walkablePolygon.forEach((p, i) => { if (i === 0) debugGfx.moveTo(p.x * roomWidth, p.y * roomHeight); else debugGfx.lineTo(p.x * roomWidth, p.y * roomHeight); });
            debugGfx.closePath(); debugGfx.strokePath();

            debugGfx.lineStyle(3, 0xff0000, 0.8); debugGfx.fillStyle(0xff0000, 0.15); debugGfx.beginPath();
            this.ottomanPolygon.forEach((p, i) => { if (i === 0) debugGfx.moveTo(p.x * roomWidth, p.y * roomHeight); else debugGfx.lineTo(p.x * roomWidth, p.y * roomHeight); });
            debugGfx.closePath(); debugGfx.strokePath(); debugGfx.fillPath();

            debugGfx.lineStyle(4, 0x00ff00, 0.8); debugGfx.beginPath();
            debugGfx.moveTo(this.greenLineStart.x * roomWidth, this.greenLineStart.y * roomHeight);
            debugGfx.lineTo(this.greenLineEnd.x * roomWidth, this.greenLineEnd.y * roomHeight);
            debugGfx.strokePath();

            debugGfx.lineStyle(2, 0xffff00, 0.6); debugGfx.beginPath();
            this.lockedDoorPoly.forEach((p, i) => { if (i === 0) debugGfx.moveTo(p.x * roomWidth, p.y * roomHeight); else debugGfx.lineTo(p.x * roomWidth, p.y * roomHeight); });
            debugGfx.closePath(); debugGfx.strokePath();

            // === INTERACTION SYSTEM ===
            this.interactiveItems = [
                { id: 'guitar', proximityCenter: { x: 0.25, y: 0.60 }, proximityRadius: 90, lineOverlay: 'line_guitar', actionOverlay: null, soundKey: 'sound_guitar' },
                { id: 'ps_controller', proximityCenter: { x: 0.65, y: 0.60 }, proximityRadius: 100, lineOverlay: 'line_ps_controller', actionOverlay: null, soundKey: null, isTVSwitch: true },
                { id: 'lights', proximityCenter: { x: 0.42, y: 0.68 }, proximityRadius: 80, lineOverlay: null, actionOverlay: null, soundKey: null, isLightSwitch: true },
            ];

            this.interactiveItems.forEach(item => {
                if (item.isLightSwitch) {
                    // Light switch has no overlay sprites â€” it changes the background
                    item.lineSprite = null;
                    item.actionSprite = null;
                    item.state = (window.roomLightMode !== 'default') ? 'active' : 'idle';
                    item._glowVisible = false;
                    return;
                }
                if (item.isTVSwitch) {
                    // TV switch: create all game overlay sprites, show the active one
                    item.lineSprite = this.add.image(0, 0, item.lineOverlay).setOrigin(0, 0).setScale(scale).setVisible(false).setDepth(10);
                    item.actionSprite = null; // not used directly
                    item.tvSprites = {};
                    Object.keys(TV_GAME_TEXTURES).forEach(mode => {
                        item.tvSprites[mode] = this.add.image(0, 0, TV_GAME_TEXTURES[mode]).setOrigin(0, 0).setScale(scale).setVisible(false).setDepth(10);
                    });
                    // Restore TV state
                    if (window.tvGameMode !== 'off') {
                        item.state = 'active';
                        item._glowVisible = false;
                        if (item.tvSprites[window.tvGameMode]) item.tvSprites[window.tvGameMode].setVisible(true);
                    } else {
                        item.state = 'idle';
                        item._glowVisible = false;
                    }
                    return;
                }
                item.lineSprite = this.add.image(0, 0, item.lineOverlay).setOrigin(0, 0).setScale(scale).setVisible(false).setDepth(10);
                if (item.actionOverlay) {
                    item.actionSprite = this.add.image(0, 0, item.actionOverlay).setOrigin(0, 0).setScale(scale).setVisible(false).setDepth(10);
                } else { item.actionSprite = null; }
                // Restore active state if this item was globally active
                if (window.activeItems[item.id]) {
                    item.state = 'active';
                    item._glowVisible = false;
                    if (item.actionSprite) item.actionSprite.setVisible(true);
                } else {
                    item.state = 'idle';
                }
            });

            // DEBUG: yellow interaction zones
            this.interactiveItems.forEach(item => {
                const cx = item.proximityCenter.x * roomWidth;
                const cy = item.proximityCenter.y * roomHeight;
                debugGfx.lineStyle(2, 0xffff00, 0.8); debugGfx.fillStyle(0xffff00, 0.1);
                debugGfx.strokeCircle(cx, cy, item.proximityRadius);
                debugGfx.fillCircle(cx, cy, item.proximityRadius);
                this.add.text(cx, cy - item.proximityRadius - 10, item.id, {
                    fontSize: '18px', fontFamily: 'Courier New', color: '#ffff00', stroke: '#000000', strokeThickness: 3
                }).setOrigin(0.5).setDepth(51);
            });

            this.debugPlayerDot = this.add.circle(0, 0, 8, 0x00ff00, 0.9).setDepth(55);

            this.interactionCooldown = 0;

            this.ePrompt = this.add.text(0, 0, '[E]', {
                fontSize: '36px', fontFamily: 'Courier New', color: '#ffffff',
                backgroundColor: '#000000aa', padding: { x: 12, y: 6 }, fontStyle: 'bold'
            }).setOrigin(0.5).setDepth(150).setVisible(false);

            this.tweens.add({
                targets: this.ePrompt, alpha: { from: 0.6, to: 1 },
                scaleX: { from: 0.95, to: 1.05 }, scaleY: { from: 0.95, to: 1.05 },
                duration: 800, yoyo: true, repeat: -1, ease: 'Sine.easeInOut'
            });

            this.eKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E);

            const eBtnSize = 70;
            this.mobileEBtn = this.add.circle(screenWidth / 2, screenHeight - 150, eBtnSize / 2, 0x4a90d9, 0.7)
                .setScrollFactor(0).setDepth(200).setVisible(false).setInteractive({ useHandCursor: true });
            this.mobileEText = this.add.text(screenWidth / 2, screenHeight - 150, 'E', {
                fontSize: '40px', fontFamily: 'Courier New', color: '#ffffff', fontStyle: 'bold'
            }).setOrigin(0.5).setScrollFactor(0).setDepth(201).setVisible(false);
            this.mobileEBtn.on('pointerdown', () => { this.handleInteraction(); });

            this.player.setCollideWorldBounds(false);

            // Fade in AFTER everything is set up â€” black cover prevents any flash
            const blackCover = this.add.rectangle(screenWidth / 2, screenHeight / 2, screenWidth * 2, screenHeight * 2, 0x000000)
                .setScrollFactor(0).setDepth(9999);
            this.tweens.add({ targets: blackCover, alpha: 0, duration: 1000, onComplete: () => { blackCover.destroy(); } });
        }

        handleInteraction() {
            const rw = this.roomWidth;
            const rh = this.roomHeight;

            // Check what item the player is currently near (inside circle)
            let nearestItem = null;
            let nearestDist = Infinity;
            this.interactiveItems.forEach(item => {
                const cx = item.proximityCenter.x * rw;
                const cy = item.proximityCenter.y * rh;
                const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, cx, cy);
                if (dist < item.proximityRadius && dist < nearestDist) { nearestDist = dist; nearestItem = item; }
            });

            // Can only interact when inside a circle
            if (!nearestItem) return;

            // === LIGHT SWITCH: cycles through modes ===
            if (nearestItem.isLightSwitch) {
                const currentIdx = LIGHT_MODES.indexOf(window.roomLightMode);
                const nextIdx = (currentIdx + 1) % LIGHT_MODES.length;
                window.roomLightMode = LIGHT_MODES[nextIdx];

                // Swap background texture
                const newKey = window.roomLightMode === 'default' ? 'room1' : ('room1_' + window.roomLightMode);
                this.bg.setTexture(newKey);

                // Update item state
                nearestItem.state = (window.roomLightMode !== 'default') ? 'active' : 'idle';
                this.interactionCooldown = 500;
                return;
            }

            // === TV SWITCH: cycles through games ===
            if (nearestItem.isTVSwitch) {
                // Hide current game overlay
                if (window.tvGameMode !== 'off' && nearestItem.tvSprites[window.tvGameMode]) {
                    nearestItem.tvSprites[window.tvGameMode].setVisible(false);
                }

                const currentIdx = TV_GAMES.indexOf(window.tvGameMode);
                const nextIdx = (currentIdx + 1) % TV_GAMES.length;
                window.tvGameMode = TV_GAMES[nextIdx];

                // Show new game overlay
                if (window.tvGameMode !== 'off' && nearestItem.tvSprites[window.tvGameMode]) {
                    nearestItem.tvSprites[window.tvGameMode].setVisible(true);
                }

                // Update item state
                nearestItem.state = (window.tvGameMode !== 'off') ? 'active' : 'idle';
                window.activeItems[nearestItem.id] = (window.tvGameMode !== 'off') ? true : undefined;
                if (window.tvGameMode === 'off') delete window.activeItems[nearestItem.id];
                this.interactionCooldown = 500;
                return;
            }

            // If this item is already active â€” turn it OFF
            if (nearestItem.state === 'active') {
                if (nearestItem.actionSprite) nearestItem.actionSprite.setVisible(false);
                nearestItem.lineSprite.setVisible(false);
                nearestItem._glowVisible = false;
                // Stop global audio if this item had sound
                if (window.activeAudio && window.activeAudio.itemId === nearestItem.id && window.activeAudio.sound) {
                    window.activeAudio.sound.stop();
                    window.activeAudio.sound.destroy();
                    window.activeAudio = null;
                }
                delete window.activeItems[nearestItem.id];
                nearestItem.state = 'idle';
                this.interactionCooldown = 500;
                return;
            }

            // If near an item â€” turn it ON (line glow stays since we're in circle)
            if (nearestItem.state === 'near') {
                if (nearestItem.actionSprite) { nearestItem.actionSprite.setVisible(true); }
                // Start global audio if item has sound
                if (nearestItem.soundKey) {
                    if (window.activeAudio && window.activeAudio.sound) {
                        window.activeAudio.sound.stop();
                        window.activeAudio.sound.destroy();
                    }
                    const snd = this.sound.add(nearestItem.soundKey, { loop: true, volume: 0.5 });
                    snd.play();
                    window.activeAudio = { itemId: nearestItem.id, soundKey: nearestItem.soundKey, sound: snd };
                }
                window.activeItems[nearestItem.id] = true;
                nearestItem.state = 'active';
                nearestItem._glowVisible = true;
            }
        }

        pointInPolygon(px, py, polygon, rw, rh) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x * rw, yi = polygon[i].y * rh;
                const xj = polygon[j].x * rw, yj = polygon[j].y * rh;
                const intersect = ((yi > py) !== (yj > py)) && (px < (xj - xi) * (py - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
            const dot = A * C + B * D, lenSq = C * C + D * D;
            let t = lenSq !== 0 ? dot / lenSq : -1;
            t = Math.max(0, Math.min(1, t));
            const xx = x1 + t * C, yy = y1 + t * D;
            return Math.sqrt((px - xx) * (px - xx) + (py - yy) * (py - yy));
        }

        update() {
            const moveSpeed = 250;
            const rw = this.roomWidth;
            const rh = this.roomHeight;

            if (Phaser.Input.Keyboard.JustDown(this.eKey)) { this.handleInteraction(); }
            if (this.interactionCooldown > 0) { this.interactionCooldown -= this.game.loop.delta; }

            let vx = 0, vy = 0;
            const left = this.wasd.left.isDown || this.cursors.left.isDown || this.virtualInput.left;
            const right = this.wasd.right.isDown || this.cursors.right.isDown || this.virtualInput.right;
            const up = this.wasd.up.isDown || this.cursors.up.isDown || this.virtualInput.up;
            const down = this.wasd.down.isDown || this.cursors.down.isDown || this.virtualInput.down;

            if (left) vx = -moveSpeed; else if (right) vx = moveSpeed;
            if (up) vy = -moveSpeed; else if (down) vy = moveSpeed;
            const usingKeyboard = left || right || up || down;
            if (usingKeyboard) { this.targetX = null; this.targetY = null; }

            if (this.targetX !== null && this.targetY !== null) {
                const distance = Phaser.Math.Distance.Between(this.player.x, this.player.y, this.targetX, this.targetY);
                if (distance < 10) { this.targetX = null; this.targetY = null; }
                else { const angle = Math.atan2(this.targetY - this.player.y, this.targetX - this.player.x); vx = Math.cos(angle) * moveSpeed; vy = Math.sin(angle) * moveSpeed; }
            }

            const dt = this.game.loop.delta / 1000;
            const nextX = this.player.x + vx * dt;
            const nextY = this.player.y + vy * dt;
            const inOuter = this.pointInPolygon(nextX, nextY, this.walkablePolygon, rw, rh);
            const inOttoman = this.pointInPolygon(nextX, nextY, this.ottomanPolygon, rw, rh);

            if (inOuter && !inOttoman) { this.player.body.setVelocity(vx, vy); }
            else {
                const xOk = this.pointInPolygon(this.player.x + vx * dt, this.player.y, this.walkablePolygon, rw, rh) && !this.pointInPolygon(this.player.x + vx * dt, this.player.y, this.ottomanPolygon, rw, rh);
                const yOk = this.pointInPolygon(this.player.x, this.player.y + vy * dt, this.walkablePolygon, rw, rh) && !this.pointInPolygon(this.player.x, this.player.y + vy * dt, this.ottomanPolygon, rw, rh);
                if (xOk && !yOk) this.player.body.setVelocity(vx, 0);
                else if (yOk && !xOk) this.player.body.setVelocity(0, vy);
                else this.player.body.setVelocity(0, 0);
            }

            if (!usingKeyboard && this.targetX === null) { this.player.body.setVelocity(0, 0); }

            if (!this.isTransitioning) {
                const dist = this.pointToLineDistance(this.player.x, this.player.y, this.greenLineStart.x * rw, this.greenLineStart.y * rh, this.greenLineEnd.x * rw, this.greenLineEnd.y * rh);
                if (dist < 30) {
                    this.isTransitioning = true;
                    this.player.body.setVelocity(0, 0);
                    // Clean up visuals before transitioning (audio + activeItems persist globally)
                    this.interactiveItems.forEach(item => {
                        if (item.state === 'active') {
                            if (item.actionSprite) item.actionSprite.setVisible(false);
                            if (item.lineSprite) item.lineSprite.setVisible(false);
                            // Hide TV game sprites
                            if (item.tvSprites) Object.values(item.tvSprites).forEach(s => s.setVisible(false));
                            item._glowVisible = false;
                        }
                    });
                    this.scene.transition({
                        target: 'StudioScene',
                        data: { fromLiving: true },
                        duration: 800,
                        moveBelow: true,
                        onUpdate: (progress) => { this.cameras.main.setAlpha(1 - progress); }
                    });
                }
            }

            if (this.pointInPolygon(this.player.x, this.player.y, this.lockedDoorPoly, rw, rh)) {
                if (this.lockedDoorTimer <= 0) {
                    this.lockedDoorTimer = 2500;
                    this.tweens.add({ targets: this.lockedDoorMessage, alpha: 1, duration: 300 });
                    this.time.delayedCall(2500, () => { this.tweens.add({ targets: this.lockedDoorMessage, alpha: 0, duration: 300 }); });
                }
            }
            if (this.lockedDoorTimer > 0) this.lockedDoorTimer -= this.game.loop.delta;

            const speed = this.player.body.velocity.length();
            if (speed > 10) {
                const angle = Math.atan2(this.player.body.velocity.y, this.player.body.velocity.x);
                const deg = Phaser.Math.RadToDeg(angle);
                if (deg > -45 && deg <= 45) { this.player.anims.play('walk-right', true); this.playerDirection = 'right'; }
                else if (deg > 45 && deg <= 135) { this.player.anims.play('walk-down', true); this.playerDirection = 'down'; }
                else if (deg > 135 || deg <= -135) { this.player.anims.play('walk-left', true); this.playerDirection = 'left'; }
                else { this.player.anims.play('walk-up', true); this.playerDirection = 'up'; }
            } else { this.player.anims.play('idle-' + this.playerDirection, true); }

            // --- INTERACTION PROXIMITY CHECK (skipped during cooldown) ---
            let playerInCircle = false;
            if (this.interactionCooldown <= 0) {
                this.interactiveItems.forEach(item => {
                    const cx = item.proximityCenter.x * rw, cy = item.proximityCenter.y * rh;
                    const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, cx, cy);
                    const inRange = dist < item.proximityRadius;

                    // Light switch: no line glow, just track proximity for [E] prompt
                    if (item.isLightSwitch) {
                        if (inRange) {
                            if (item.state === 'idle') item.state = 'near';
                            playerInCircle = true;
                        } else {
                            if (item.state === 'near') item.state = 'idle';
                        }
                        return;
                    }

                    if (item.state === 'active') {
                        // Active item: show/hide line glow when entering/leaving circle
                        if (inRange) {
                            if (!item._glowVisible) {
                                item.lineSprite.setVisible(true); item.lineSprite.setAlpha(0);
                                this.tweens.add({ targets: item.lineSprite, alpha: 1, duration: 300 });
                                item._glowVisible = true;
                            }
                            playerInCircle = true;
                        } else {
                            if (item._glowVisible) {
                                this.tweens.add({ targets: item.lineSprite, alpha: 0, duration: 200, onComplete: () => { item.lineSprite.setVisible(false); } });
                                item._glowVisible = false;
                            }
                        }
                        return;
                    }

                    if (inRange) {
                        if (item.state !== 'near') {
                            item.lineSprite.setVisible(true); item.lineSprite.setAlpha(0);
                            this.tweens.add({ targets: item.lineSprite, alpha: 1, duration: 300 });
                            item.state = 'near';
                        }
                        playerInCircle = true;
                    } else if (item.state === 'near') {
                        this.tweens.add({ targets: item.lineSprite, alpha: 0, duration: 200, onComplete: () => { item.lineSprite.setVisible(false); } });
                        item.state = 'idle';
                    }
                });
            }

            this.debugPlayerDot.setPosition(this.player.x, this.player.y);
            this.debugPlayerDot.setFillStyle(playerInCircle ? 0xffffff : 0x00ff00, 0.9);

            // [E] prompt â€” show context label when near special switches
            if (playerInCircle) {
                this.ePrompt.setPosition(this.player.x, this.player.y - 140);
                const nearLight = this.interactiveItems.find(i => i.isLightSwitch &&
                    Phaser.Math.Distance.Between(this.player.x, this.player.y, i.proximityCenter.x * rw, i.proximityCenter.y * rh) < i.proximityRadius);
                const nearTV = this.interactiveItems.find(i => i.isTVSwitch &&
                    Phaser.Math.Distance.Between(this.player.x, this.player.y, i.proximityCenter.x * rw, i.proximityCenter.y * rh) < i.proximityRadius);
                if (nearLight) {
                    const modeLabel = window.roomLightMode === 'default' ? 'OFF' : window.roomLightMode.toUpperCase();
                    this.ePrompt.setText('[E] Lights: ' + modeLabel);
                } else if (nearTV) {
                    const gameLabel = window.tvGameMode === 'off' ? 'OFF' : window.tvGameMode.replace('_', ' ').toUpperCase();
                    this.ePrompt.setText('[E] TV: ' + gameLabel);
                } else {
                    this.ePrompt.setText('[E]');
                }
                this.ePrompt.setVisible(true); this.mobileEBtn.setVisible(true); this.mobileEText.setVisible(true);
            } else {
                this.ePrompt.setText('[E]');
                this.ePrompt.setVisible(false); this.mobileEBtn.setVisible(false); this.mobileEText.setVisible(false);
            }
        }
    }

    // --- Ð¡Ð¢Ð£Ð”Ð˜Ð¯ ---
    class StudioScene extends Phaser.Scene {
        constructor() { super('StudioScene'); }

        preload() {
            const style = MAP_STYLES[window.mapStyle] || MAP_STYLES['default'];
            this.load.image('room2', style.room2);

            // --- INTERACTION OVERLAYS for Room 2 (Studio) ---
            this.load.image('line_audio_interface', '/assets/interaction/action_audio_interface.png');
            this.load.image('line_rick_owens', '/assets/interaction/action_rick_owens.png');

            // --- LIGHT VARIANTS for Room 2 ---
            this.load.image('room2_blue', 'assets/default/room2_blue.png');
            this.load.image('room2_pink', 'assets/default/room2_pink.png');
            this.load.image('room2_green', 'assets/default/room2_green.png');

            // --- AUDIO for interactions (load all so they persist across scenes) ---
            this.load.audio('sound_guitar', '/assets/sound/sound_guitar.mp3');
            this.load.audio('sound_audio_interface', '/assets/sound/sound_audio_interface.mp3');
        }

        create() {
            const screenWidth = this.scale.width;
            const screenHeight = this.scale.height;

            // Determine which room2 texture to use based on current light mode
            const lightMode = window.roomLightMode || 'default';
            const room2Key = lightMode === 'default' ? 'room2' : ('room2_' + lightMode);
            const bg = this.add.image(0, 0, room2Key).setOrigin(0, 0);
            this.bg = bg; // store reference for texture swapping
            const scaleX = screenWidth / bg.width;
            const scaleY = screenHeight / bg.height;
            const scale = Math.max(scaleX, scaleY);
            bg.setScale(scale);

            const roomWidth = bg.width * scale;
            const roomHeight = bg.height * scale;

            this.physics.world.setBounds(0, 0, roomWidth, roomHeight);

            const fromLiving = this.scene.settings.data?.fromLiving;
            if (fromLiving) { this.player = this.physics.add.sprite(roomWidth * 0.50, roomHeight * 0.70, 'playerSprite'); }
            else { this.player = this.physics.add.sprite(roomWidth * 0.40, roomHeight * 0.80, 'playerSprite'); }

            this.player.setScale(0.7);
            this.player.setOrigin(0.5, 1);
            this.player.setCollideWorldBounds(true);
            this.player.body.setSize(20, 10);
            this.player.body.setOffset(22, 54);
            this.player.anims.play('idle-down');
            this.playerDirection = 'down';

            this.cameras.main.startFollow(this.player, true, 0.1, 0.1);
            this.cameras.main.setBounds(0, 0, roomWidth, roomHeight);
            this.cameras.main.setZoom(1.4);

            this.targetX = null;
            this.targetY = null;
            this.isTransitioning = false;

            this.cursors = this.input.keyboard.createCursorKeys();
            this.wasd = this.input.keyboard.addKeys({
                up: Phaser.Input.Keyboard.KeyCodes.W, down: Phaser.Input.Keyboard.KeyCodes.S,
                left: Phaser.Input.Keyboard.KeyCodes.A, right: Phaser.Input.Keyboard.KeyCodes.D
            });

            const buttonSize = 80, buttonAlpha = 0.6, buttonColor = 0x444444;
            this.btnLeft = this.add.circle(120, screenHeight - 150, buttonSize/2, buttonColor, buttonAlpha).setScrollFactor(0).setInteractive();
            this.add.text(120, screenHeight - 150, 'â—„', { fontSize: '50px', color: '#ffffff' }).setOrigin(0.5).setScrollFactor(0);
            this.btnRight = this.add.circle(280, screenHeight - 150, buttonSize/2, buttonColor, buttonAlpha).setScrollFactor(0).setInteractive();
            this.add.text(280, screenHeight - 150, 'â–º', { fontSize: '50px', color: '#ffffff' }).setOrigin(0.5).setScrollFactor(0);
            this.btnUp = this.add.circle(screenWidth - 120, screenHeight - 230, buttonSize/2, buttonColor, buttonAlpha).setScrollFactor(0).setInteractive();
            this.add.text(screenWidth - 120, screenHeight - 230, 'â–²', { fontSize: '50px', color: '#ffffff' }).setOrigin(0.5).setScrollFactor(0);
            this.btnDown = this.add.circle(screenWidth - 120, screenHeight - 70, buttonSize/2, buttonColor, buttonAlpha).setScrollFactor(0).setInteractive();
            this.add.text(screenWidth - 120, screenHeight - 70, 'â–¼', { fontSize: '50px', color: '#ffffff' }).setOrigin(0.5).setScrollFactor(0);

            this.virtualInput = { left: false, right: false, up: false, down: false };
            this.btnLeft.on('pointerdown', () => { this.virtualInput.left = true; }); this.btnLeft.on('pointerup', () => { this.virtualInput.left = false; }); this.btnLeft.on('pointerout', () => { this.virtualInput.left = false; });
            this.btnRight.on('pointerdown', () => { this.virtualInput.right = true; }); this.btnRight.on('pointerup', () => { this.virtualInput.right = false; }); this.btnRight.on('pointerout', () => { this.virtualInput.right = false; });
            this.btnUp.on('pointerdown', () => { this.virtualInput.up = true; }); this.btnUp.on('pointerup', () => { this.virtualInput.up = false; }); this.btnUp.on('pointerout', () => { this.virtualInput.up = false; });
            this.btnDown.on('pointerdown', () => { this.virtualInput.down = true; }); this.btnDown.on('pointerup', () => { this.virtualInput.down = false; }); this.btnDown.on('pointerout', () => { this.virtualInput.down = false; });

            this.input.on('pointerdown', (pointer) => {
                if (this.isTransitioning) return;
                if (pointer.y > screenHeight - 300) return;
                const worldPoint = this.cameras.main.getWorldPoint(pointer.x, pointer.y);
                this.targetX = worldPoint.x; this.targetY = worldPoint.y;
                this.physics.moveToObject(this.player, worldPoint, 250);
            });

            this.walkablePolygon = [
                { x: 0.08, y: 0.72 }, { x: 0.26, y: 0.625 }, { x: 0.35, y: 0.68 },
                { x: 0.36, y: 0.675 }, { x: 0.32, y: 0.63 }, { x: 0.38, y: 0.60 },
                { x: 0.40, y: 0.66 }, { x: 0.47, y: 0.70 }, { x: 0.53, y: 0.66 },
                { x: 0.56, y: 0.65 }, { x: 0.51, y: 0.61 }, { x: 0.53, y: 0.60 },
                { x: 0.54, y: 0.54 }, { x: 0.59, y: 0.51 }, { x: 0.645, y: 0.55 },
                { x: 0.645, y: 0.60 }, { x: 0.73, y: 0.66 }, { x: 0.27, y: 0.84 },
            ];
            this.chairPolygon = [
                { x: 0.40, y: 0.66 }, { x: 0.47, y: 0.60 },
                { x: 0.54, y: 0.66 }, { x: 0.47, y: 0.70 },
            ];

            this.roomWidth = roomWidth;
            this.roomHeight = roomHeight;
            this.greenLineStart = { x: 0.26, y: 0.85 };
            this.greenLineEnd = { x: 0.72, y: 0.67 };

            this.lockedDoorPoly = [
                { x: 0.04, y: 0.58 }, { x: 0.14, y: 0.52 },
                { x: 0.14, y: 0.62 }, { x: 0.04, y: 0.68 },
            ];
            this.lockedDoorMessage = this.add.text(roomWidth * 0.20, roomHeight * 0.45,
                'Ð•Ñ‰Ðµ Ð½Ðµ Ð²Ñ€ÐµÐ¼Ñ', {
                fontSize: '48px', fontFamily: 'Courier New', color: '#ffffff',
                backgroundColor: '#000000', padding: { x: 25, y: 12 }, alpha: 0
            }).setOrigin(0.5).setDepth(100);
            this.lockedDoorTimer = 0;

            const debugGfx = this.add.graphics();
            debugGfx.setDepth(50);

            debugGfx.lineStyle(3, 0xff0000, 0.8); debugGfx.beginPath();
            this.walkablePolygon.forEach((p, i) => { if (i === 0) debugGfx.moveTo(p.x * roomWidth, p.y * roomHeight); else debugGfx.lineTo(p.x * roomWidth, p.y * roomHeight); });
            debugGfx.closePath(); debugGfx.strokePath();

            debugGfx.lineStyle(3, 0xff0000, 0.8); debugGfx.fillStyle(0xff0000, 0.15); debugGfx.beginPath();
            this.chairPolygon.forEach((p, i) => { if (i === 0) debugGfx.moveTo(p.x * roomWidth, p.y * roomHeight); else debugGfx.lineTo(p.x * roomWidth, p.y * roomHeight); });
            debugGfx.closePath(); debugGfx.strokePath(); debugGfx.fillPath();

            debugGfx.lineStyle(4, 0x00ff00, 0.8); debugGfx.beginPath();
            debugGfx.moveTo(this.greenLineStart.x * roomWidth, this.greenLineStart.y * roomHeight);
            debugGfx.lineTo(this.greenLineEnd.x * roomWidth, this.greenLineEnd.y * roomHeight);
            debugGfx.strokePath();

            debugGfx.lineStyle(2, 0xffff00, 0.6); debugGfx.beginPath();
            this.lockedDoorPoly.forEach((p, i) => { if (i === 0) debugGfx.moveTo(p.x * roomWidth, p.y * roomHeight); else debugGfx.lineTo(p.x * roomWidth, p.y * roomHeight); });
            debugGfx.closePath(); debugGfx.strokePath();

            // === INTERACTION SYSTEM ===
            this.interactiveItems = [
                { id: 'audio_interface', proximityCenter: { x: 0.35, y: 0.60 }, proximityRadius: 90, lineOverlay: 'line_audio_interface', actionOverlay: null, soundKey: 'sound_audio_interface' },
                { id: 'rick_owens', proximityCenter: { x: 0.60, y: 0.53 }, proximityRadius: 90, lineOverlay: 'line_rick_owens', actionOverlay: null, soundKey: null },
                { id: 'lights', proximityCenter: { x: 0.20, y: 0.70 }, proximityRadius: 80, lineOverlay: null, actionOverlay: null, soundKey: null, isLightSwitch: true },
            ];

            this.interactiveItems.forEach(item => {
                if (item.isLightSwitch) {
                    // Light switch has no overlay sprites â€” it changes the background
                    item.lineSprite = null;
                    item.actionSprite = null;
                    item.state = (window.roomLightMode !== 'default') ? 'active' : 'idle';
                    item._glowVisible = false;
                    return;
                }
                item.lineSprite = this.add.image(0, 0, item.lineOverlay).setOrigin(0, 0).setScale(scale).setVisible(false).setDepth(10);
                if (item.actionOverlay) { item.actionSprite = this.add.image(0, 0, item.actionOverlay).setOrigin(0, 0).setScale(scale).setVisible(false).setDepth(10); }
                else { item.actionSprite = null; }
                // Restore active state if this item was globally active
                if (window.activeItems[item.id]) {
                    item.state = 'active';
                    item._glowVisible = false;
                    if (item.actionSprite) item.actionSprite.setVisible(true);
                } else {
                    item.state = 'idle';
                }
            });

            this.interactiveItems.forEach(item => {
                const cx = item.proximityCenter.x * roomWidth, cy = item.proximityCenter.y * roomHeight;
                debugGfx.lineStyle(2, 0xffff00, 0.8); debugGfx.fillStyle(0xffff00, 0.1);
                debugGfx.strokeCircle(cx, cy, item.proximityRadius);
                debugGfx.fillCircle(cx, cy, item.proximityRadius);
                this.add.text(cx, cy - item.proximityRadius - 10, item.id, {
                    fontSize: '18px', fontFamily: 'Courier New', color: '#ffff00', stroke: '#000000', strokeThickness: 3
                }).setOrigin(0.5).setDepth(51);
            });

            this.debugPlayerDot = this.add.circle(0, 0, 8, 0x00ff00, 0.9).setDepth(55);

            this.interactionCooldown = 0;

            this.ePrompt = this.add.text(0, 0, '[E]', {
                fontSize: '36px', fontFamily: 'Courier New', color: '#ffffff',
                backgroundColor: '#000000aa', padding: { x: 12, y: 6 }, fontStyle: 'bold'
            }).setOrigin(0.5).setDepth(150).setVisible(false);

            this.tweens.add({
                targets: this.ePrompt, alpha: { from: 0.6, to: 1 },
                scaleX: { from: 0.95, to: 1.05 }, scaleY: { from: 0.95, to: 1.05 },
                duration: 800, yoyo: true, repeat: -1, ease: 'Sine.easeInOut'
            });

            this.eKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E);

            const eBtnSize = 70;
            this.mobileEBtn = this.add.circle(screenWidth / 2, screenHeight - 150, eBtnSize / 2, 0x4a90d9, 0.7)
                .setScrollFactor(0).setDepth(200).setVisible(false).setInteractive({ useHandCursor: true });
            this.mobileEText = this.add.text(screenWidth / 2, screenHeight - 150, 'E', {
                fontSize: '40px', fontFamily: 'Courier New', color: '#ffffff', fontStyle: 'bold'
            }).setOrigin(0.5).setScrollFactor(0).setDepth(201).setVisible(false);
            this.mobileEBtn.on('pointerdown', () => { this.handleInteraction(); });

            this.player.setCollideWorldBounds(false);

            // Fade in AFTER everything is set up â€” black cover prevents any flash
            const blackCover = this.add.rectangle(screenWidth / 2, screenHeight / 2, screenWidth * 2, screenHeight * 2, 0x000000)
                .setScrollFactor(0).setDepth(9999);
            this.tweens.add({ targets: blackCover, alpha: 0, duration: 1000, onComplete: () => { blackCover.destroy(); } });
        }

        handleInteraction() {
            const rw = this.roomWidth, rh = this.roomHeight;

            // Check what item the player is currently near (inside circle)
            let nearestItem = null, nearestDist = Infinity;
            this.interactiveItems.forEach(item => {
                const cx = item.proximityCenter.x * rw, cy = item.proximityCenter.y * rh;
                const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, cx, cy);
                if (dist < item.proximityRadius && dist < nearestDist) { nearestDist = dist; nearestItem = item; }
            });

            // Can only interact when inside a circle
            if (!nearestItem) return;

            // === LIGHT SWITCH: cycles through modes ===
            if (nearestItem.isLightSwitch) {
                const currentIdx = LIGHT_MODES.indexOf(window.roomLightMode);
                const nextIdx = (currentIdx + 1) % LIGHT_MODES.length;
                window.roomLightMode = LIGHT_MODES[nextIdx];

                // Swap background texture
                const newKey = window.roomLightMode === 'default' ? 'room2' : ('room2_' + window.roomLightMode);
                this.bg.setTexture(newKey);

                // Update item state
                nearestItem.state = (window.roomLightMode !== 'default') ? 'active' : 'idle';
                this.interactionCooldown = 500;
                return;
            }

            // If this item is already active â€” turn it OFF
            if (nearestItem.state === 'active') {
                if (nearestItem.actionSprite) nearestItem.actionSprite.setVisible(false);
                nearestItem.lineSprite.setVisible(false);
                nearestItem._glowVisible = false;
                // Stop global audio if this item had sound
                if (window.activeAudio && window.activeAudio.itemId === nearestItem.id && window.activeAudio.sound) {
                    window.activeAudio.sound.stop();
                    window.activeAudio.sound.destroy();
                    window.activeAudio = null;
                }
                delete window.activeItems[nearestItem.id];
                nearestItem.state = 'idle';
                this.interactionCooldown = 500;
                return;
            }

            // If near an item â€” turn it ON (line glow stays since we're in circle)
            if (nearestItem.state === 'near') {
                if (nearestItem.actionSprite) { nearestItem.actionSprite.setVisible(true); }
                // Start global audio if item has sound
                if (nearestItem.soundKey) {
                    if (window.activeAudio && window.activeAudio.sound) {
                        window.activeAudio.sound.stop();
                        window.activeAudio.sound.destroy();
                    }
                    const snd = this.sound.add(nearestItem.soundKey, { loop: true, volume: 0.5 });
                    snd.play();
                    window.activeAudio = { itemId: nearestItem.id, soundKey: nearestItem.soundKey, sound: snd };
                }
                window.activeItems[nearestItem.id] = true;
                nearestItem.state = 'active';
                nearestItem._glowVisible = true;
            }
        }

        pointInPolygon(px, py, polygon, rw, rh) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x * rw, yi = polygon[i].y * rh;
                const xj = polygon[j].x * rw, yj = polygon[j].y * rh;
                const intersect = ((yi > py) !== (yj > py)) && (px < (xj - xi) * (py - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
            const dot = A * C + B * D, lenSq = C * C + D * D;
            let t = lenSq !== 0 ? dot / lenSq : -1;
            t = Math.max(0, Math.min(1, t));
            const xx = x1 + t * C, yy = y1 + t * D;
            return Math.sqrt((px - xx) * (px - xx) + (py - yy) * (py - yy));
        }

        update() {
            const moveSpeed = 250;
            const rw = this.roomWidth, rh = this.roomHeight;

            if (Phaser.Input.Keyboard.JustDown(this.eKey)) { this.handleInteraction(); }
            if (this.interactionCooldown > 0) { this.interactionCooldown -= this.game.loop.delta; }

            let vx = 0, vy = 0;
            const left = this.wasd.left.isDown || this.cursors.left.isDown || this.virtualInput.left;
            const right = this.wasd.right.isDown || this.cursors.right.isDown || this.virtualInput.right;
            const up = this.wasd.up.isDown || this.cursors.up.isDown || this.virtualInput.up;
            const down = this.wasd.down.isDown || this.cursors.down.isDown || this.virtualInput.down;

            if (left) vx = -moveSpeed; else if (right) vx = moveSpeed;
            if (up) vy = -moveSpeed; else if (down) vy = moveSpeed;
            const usingKeyboard = left || right || up || down;
            if (usingKeyboard) { this.targetX = null; this.targetY = null; }

            if (this.targetX !== null && this.targetY !== null) {
                const distance = Phaser.Math.Distance.Between(this.player.x, this.player.y, this.targetX, this.targetY);
                if (distance < 10) { this.targetX = null; this.targetY = null; }
                else { const angle = Math.atan2(this.targetY - this.player.y, this.targetX - this.player.x); vx = Math.cos(angle) * moveSpeed; vy = Math.sin(angle) * moveSpeed; }
            }

            const dt = this.game.loop.delta / 1000;
            const nextX = this.player.x + vx * dt, nextY = this.player.y + vy * dt;
            const inOuter = this.pointInPolygon(nextX, nextY, this.walkablePolygon, rw, rh);
            const inChair = this.pointInPolygon(nextX, nextY, this.chairPolygon, rw, rh);

            if (inOuter && !inChair) { this.player.body.setVelocity(vx, vy); }
            else {
                const xOk = this.pointInPolygon(this.player.x + vx * dt, this.player.y, this.walkablePolygon, rw, rh) && !this.pointInPolygon(this.player.x + vx * dt, this.player.y, this.chairPolygon, rw, rh);
                const yOk = this.pointInPolygon(this.player.x, this.player.y + vy * dt, this.walkablePolygon, rw, rh) && !this.pointInPolygon(this.player.x, this.player.y + vy * dt, this.chairPolygon, rw, rh);
                if (xOk && !yOk) this.player.body.setVelocity(vx, 0);
                else if (yOk && !xOk) this.player.body.setVelocity(0, vy);
                else this.player.body.setVelocity(0, 0);
            }

            if (!usingKeyboard && this.targetX === null) { this.player.body.setVelocity(0, 0); }

            if (!this.isTransitioning) {
                const dist = this.pointToLineDistance(this.player.x, this.player.y, this.greenLineStart.x * rw, this.greenLineStart.y * rh, this.greenLineEnd.x * rw, this.greenLineEnd.y * rh);
                if (dist < 30) {
                    this.isTransitioning = true;
                    this.player.body.setVelocity(0, 0);
                    // Clean up visuals before transitioning (audio + activeItems persist globally)
                    this.interactiveItems.forEach(item => {
                        if (item.state === 'active') {
                            if (item.actionSprite) item.actionSprite.setVisible(false);
                            if (item.lineSprite) item.lineSprite.setVisible(false);
                            // Hide TV game sprites
                            if (item.tvSprites) Object.values(item.tvSprites).forEach(s => s.setVisible(false));
                            item._glowVisible = false;
                        }
                    });
                    this.scene.transition({
                        target: 'MainScene',
                        data: { fromStudio: true },
                        duration: 800,
                        moveBelow: true,
                        onUpdate: (progress) => { this.cameras.main.setAlpha(1 - progress); }
                    });
                }
            }

            if (this.pointInPolygon(this.player.x, this.player.y, this.lockedDoorPoly, rw, rh)) {
                if (this.lockedDoorTimer <= 0) {
                    this.lockedDoorTimer = 2500;
                    this.tweens.add({ targets: this.lockedDoorMessage, alpha: 1, duration: 300 });
                    this.time.delayedCall(2500, () => { this.tweens.add({ targets: this.lockedDoorMessage, alpha: 0, duration: 300 }); });
                }
            }
            if (this.lockedDoorTimer > 0) this.lockedDoorTimer -= this.game.loop.delta;

            const speed = this.player.body.velocity.length();
            if (speed > 10) {
                const angle = Math.atan2(this.player.body.velocity.y, this.player.body.velocity.x);
                const deg = Phaser.Math.RadToDeg(angle);
                if (deg > -45 && deg <= 45) { this.player.anims.play('walk-right', true); this.playerDirection = 'right'; }
                else if (deg > 45 && deg <= 135) { this.player.anims.play('walk-down', true); this.playerDirection = 'down'; }
                else if (deg > 135 || deg <= -135) { this.player.anims.play('walk-left', true); this.playerDirection = 'left'; }
                else { this.player.anims.play('walk-up', true); this.playerDirection = 'up'; }
            } else { this.player.anims.play('idle-' + this.playerDirection, true); }

            // --- INTERACTION PROXIMITY CHECK (skipped during cooldown) ---
            let playerInCircle = false;
            if (this.interactionCooldown <= 0) {
                this.interactiveItems.forEach(item => {
                    const cx = item.proximityCenter.x * rw, cy = item.proximityCenter.y * rh;
                    const dist = Phaser.Math.Distance.Between(this.player.x, this.player.y, cx, cy);
                    const inRange = dist < item.proximityRadius;

                    // Light switch: no line glow, just track proximity for [E] prompt
                    if (item.isLightSwitch) {
                        if (inRange) {
                            if (item.state === 'idle') item.state = 'near';
                            playerInCircle = true;
                        } else {
                            if (item.state === 'near') item.state = 'idle';
                        }
                        return;
                    }

                    if (item.state === 'active') {
                        // Active item: show/hide line glow when entering/leaving circle
                        if (inRange) {
                            if (!item._glowVisible) {
                                item.lineSprite.setVisible(true); item.lineSprite.setAlpha(0);
                                this.tweens.add({ targets: item.lineSprite, alpha: 1, duration: 300 });
                                item._glowVisible = true;
                            }
                            playerInCircle = true;
                        } else {
                            if (item._glowVisible) {
                                this.tweens.add({ targets: item.lineSprite, alpha: 0, duration: 200, onComplete: () => { item.lineSprite.setVisible(false); } });
                                item._glowVisible = false;
                            }
                        }
                        return;
                    }

                    if (inRange) {
                        if (item.state !== 'near') {
                            item.lineSprite.setVisible(true); item.lineSprite.setAlpha(0);
                            this.tweens.add({ targets: item.lineSprite, alpha: 1, duration: 300 });
                            item.state = 'near';
                        }
                        playerInCircle = true;
                    } else if (item.state === 'near') {
                        this.tweens.add({ targets: item.lineSprite, alpha: 0, duration: 200, onComplete: () => { item.lineSprite.setVisible(false); } });
                        item.state = 'idle';
                    }
                });
            }

            this.debugPlayerDot.setPosition(this.player.x, this.player.y);
            this.debugPlayerDot.setFillStyle(playerInCircle ? 0xffffff : 0x00ff00, 0.9);

            // [E] prompt â€” show light mode label when near light switch
            if (playerInCircle) {
                this.ePrompt.setPosition(this.player.x, this.player.y - 140);
                const nearLight = this.interactiveItems.find(i => i.isLightSwitch &&
                    Phaser.Math.Distance.Between(this.player.x, this.player.y, i.proximityCenter.x * rw, i.proximityCenter.y * rh) < i.proximityRadius);
                if (nearLight) {
                    const modeLabel = window.roomLightMode === 'default' ? 'OFF' : window.roomLightMode.toUpperCase();
                    this.ePrompt.setText('[E] Lights: ' + modeLabel);
                } else {
                    this.ePrompt.setText('[E]');
                }
                this.ePrompt.setVisible(true); this.mobileEBtn.setVisible(true); this.mobileEText.setVisible(true);
            } else {
                this.ePrompt.setText('[E]');
                this.ePrompt.setVisible(false); this.mobileEBtn.setVisible(false); this.mobileEText.setVisible(false);
            }
        }
    }

    // --- ÐšÐžÐÐ¤Ð˜Ð“Ð£Ð ÐÐ¦Ð˜Ð¯ ---
    const config = {
        type: Phaser.AUTO,
        backgroundColor: '#000000',
        scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH, width: 1080, height: 1920 },
        physics: { default: 'arcade', arcade: { debug: true, gravity: { y: 0 } } },
        render: { antialias: false, pixelArt: true },
        scene: [MenuScene, MainScene, StudioScene]
    };

    const game = new Phaser.Game(config);
</script>
</body>
</html>
