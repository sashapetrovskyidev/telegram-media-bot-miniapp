<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>My Studio</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3.60.0/dist/phaser.min.js"></script>
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            background: #1a1a1a; 
            overflow: hidden;
            font-family: 'Courier New', monospace;
        }
        canvas { display: block; }
    </style>
</head>
<body>
<script>
    // --- START MENU SCENE ---
    class MenuScene extends Phaser.Scene {
        constructor() { super('MenuScene'); }

        preload() {
            this.load.image('menuBg', 'room1_right_size.png');
            
            this.load.on('loaderror', (file) => {
                console.error('ÐžÑˆÐ¸Ð±ÐºÐ° Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸: ' + file.key);
            });
        }

        create() {
            const { width, height } = this.scale;

            this.add.image(width / 2, height / 2, 'menuBg')
                .setDisplaySize(width, height)
                .setAlpha(0.3);

            const overlay = this.add.graphics();
            overlay.fillGradientStyle(0x0a0a0a, 0x0a0a0a, 0x1a1a2e, 0x1a1a2e, 0.85);
            overlay.fillRect(0, 0, width, height);

            const menuBox = this.add.graphics();
            menuBox.lineStyle(8, 0x4a5568, 1);
            menuBox.strokeRect(width / 2 - 380, height / 2 - 250, 760, 500);
            menuBox.lineStyle(4, 0x6b7280, 1);
            menuBox.strokeRect(width / 2 - 390, height / 2 - 260, 780, 520);

            const menuBg = this.add.graphics();
            menuBg.fillStyle(0x1e293b, 0.95);
            menuBg.fillRect(width / 2 - 380, height / 2 - 250, 760, 500);

            const title = this.add.text(width / 2, height / 2 - 150, 'MY STUDIO', {
                fontSize: '96px',
                fontFamily: 'Courier New, monospace',
                color: '#94a3b8',
                fontStyle: 'bold',
                stroke: '#1e293b',
                strokeThickness: 12
            }).setOrigin(0.5);

            this.tweens.add({
                targets: title,
                alpha: { from: 0.8, to: 1 },
                scale: { from: 0.98, to: 1.02 },
                duration: 2000,
                yoyo: true,
                repeat: -1,
                ease: 'Sine.easeInOut'
            });

            const startBtnY = height / 2 + 20;
            this.createPixelButton(
                width / 2, 
                startBtnY, 
                'START GAME',
                () => {
                    this.cameras.main.fadeOut(500, 0, 0, 0);
                    this.time.delayedCall(500, () => {
                        this.scene.start('MainScene');
                    });
                }
            );

            const optionsBtnY = height / 2 + 130;
            this.createPixelButton(
                width / 2, 
                optionsBtnY, 
                'OPTIONS',
                () => {
                    this.cameras.main.shake(200, 0.002);
                }
            );

            const hint = this.add.text(width / 2, height - 120, 'ÐÐ°Ð¶Ð¼Ð¸Ñ‚Ðµ Ð½Ð° ÑÐºÑ€Ð°Ð½ Ð´Ð»Ñ Ð´Ð²Ð¸Ð¶ÐµÐ½Ð¸Ñ', {
                fontSize: '28px',
                fontFamily: 'Courier New',
                color: '#64748b',
                alpha: 0.7
            }).setOrigin(0.5);

            this.tweens.add({
                targets: hint,
                alpha: { from: 0.4, to: 0.9 },
                duration: 1500,
                yoyo: true,
                repeat: -1
            });

            this.cameras.main.fadeIn(800, 10, 10, 30);
        }

        createPixelButton(x, y, text, callback) {
            const btnWidth = 500;
            const btnHeight = 90;

            const outerBorder = this.add.graphics();
            outerBorder.lineStyle(6, 0x64748b, 1);
            outerBorder.strokeRect(x - btnWidth/2, y - btnHeight/2, btnWidth, btnHeight);

            const innerBorder = this.add.graphics();
            innerBorder.lineStyle(3, 0x475569, 1);
            innerBorder.strokeRect(x - btnWidth/2 + 8, y - btnHeight/2 + 8, btnWidth - 16, btnHeight - 16);

            const buttonBg = this.add.rectangle(x, y, btnWidth - 16, btnHeight - 16, 0x334155)
                .setInteractive({ useHandCursor: true });

            const buttonText = this.add.text(x, y, text, {
                fontSize: '42px',
                fontFamily: 'Courier New',
                color: '#cbd5e1',
                fontStyle: 'bold'
            }).setOrigin(0.5);

            const buttonGroup = [outerBorder, innerBorder, buttonBg, buttonText];

            buttonBg.on('pointerover', () => {
                buttonBg.setFillStyle(0x475569);
                buttonText.setColor('#f1f5f9');
                this.tweens.add({
                    targets: buttonGroup,
                    scale: 1.05,
                    duration: 150
                });
            });

            buttonBg.on('pointerout', () => {
                buttonBg.setFillStyle(0x334155);
                buttonText.setColor('#cbd5e1');
                this.tweens.add({
                    targets: buttonGroup,
                    scale: 1.0,
                    duration: 150
                });
            });

            buttonBg.on('pointerdown', () => {
                this.tweens.add({
                    targets: buttonGroup,
                    scale: 0.95,
                    duration: 100,
                    yoyo: true,
                    onComplete: callback
                });
            });
        }
    }

    // --- Ð“Ð›ÐÐ’ÐÐÐ¯ Ð¡Ð¦Ð•ÐÐ (Ð“ÐžÐ¡Ð¢Ð˜ÐÐÐ¯) ---
    class MainScene extends Phaser.Scene {
        constructor() { super('MainScene'); }

        preload() {
            console.log('ðŸ”„ ÐÐ°Ñ‡Ð¸Ð½Ð°ÐµÐ¼ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÑƒ Ñ€ÐµÑÑƒÑ€ÑÐ¾Ð²...');
            
            this.load.image('room1', 'room1.png');
            
            // ÐšÐ Ð˜Ð¢Ð˜Ð§ÐÐž: ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÑƒ ÑÐ¿Ñ€Ð°Ð¹Ñ‚ÑˆÐ¸Ñ‚Ð°
            this.load.spritesheet('playerSprite', 'person_model_rightest.png', {
                frameWidth: 64,
                frameHeight: 64
            });

            this.load.on('loaderror', (file) => {
                console.error('âŒ ÐžÐ¨Ð˜Ð‘ÐšÐ Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸ Ñ„Ð°Ð¹Ð»Ð°: ' + file.key);
                console.error('âŒ ÐŸÑƒÑ‚ÑŒ Ðº Ñ„Ð°Ð¹Ð»Ñƒ:', file.url);
                console.error('âŒ Ð¢Ð¸Ð¿ Ñ„Ð°Ð¹Ð»Ð°:', file.type);
            });
            
            this.load.on('complete', () => {
                console.log('âœ… Ð’ÑÐµ Ñ„Ð°Ð¹Ð»Ñ‹ Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ñ‹ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾!');
            });
            
            this.load.on('filecomplete-spritesheet-playerSprite', (key, type, data) => {
                console.log('âœ… Ð¡Ð¿Ñ€Ð°Ð¹Ñ‚ÑˆÐ¸Ñ‚ Ð¿ÐµÑ€ÑÐ¾Ð½Ð°Ð¶Ð° Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½!');
                console.log('ðŸ“Š Ð Ð°Ð·Ð¼ÐµÑ€:', data.width, 'x', data.height);
                console.log('ðŸ“Š Ð”Ð¾Ð»Ð¶Ð½Ð¾ Ð±Ñ‹Ñ‚ÑŒ: 256x256 (4x4 frames Ð¿Ð¾ 64px)');
            });
            
            this.load.on('filecomplete-image-room1', () => {
                console.log('âœ… ÐšÐ¾Ð¼Ð½Ð°Ñ‚Ð° Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ð°!');
            });
        }

        create() {
            const screenWidth = this.scale.width;
            const screenHeight = this.scale.height;

            const bg = this.add.image(0, 0, 'room1').setOrigin(0, 0);
            
            const scaleX = screenWidth / bg.width;
            const scaleY = screenHeight / bg.height;
            const scale = Math.max(scaleX, scaleY);
            
            bg.setScale(scale);
            
            const roomWidth = bg.width * scale;
            const roomHeight = bg.height * scale;

            this.physics.world.setBounds(0, 0, roomWidth, roomHeight);

            // Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð°Ð½Ð¸Ð¼Ð°Ñ†Ð¸Ð¹ Ð´Ð»Ñ ÐÐžÐ’ÐžÐ“Ðž ÑÐ¿Ñ€Ð°Ð¹Ñ‚ÑˆÐ¸Ñ‚Ð°
            if (!this.anims.exists('walk-down')) {
                // DOWN (ÑÐ¿Ð¸Ð½Ð¾Ð¹, Ñ€ÑÐ´ 0) - Ñ„Ñ€ÐµÐ¹Ð¼Ñ‹ 0,1,2,3
                this.anims.create({
                    key: 'walk-down',
                    frames: this.anims.generateFrameNumbers('playerSprite', { start: 0, end: 3 }),
                    frameRate: 8,
                    repeat: -1
                });

                // LEFT (Ð²Ð»ÐµÐ²Ð¾, Ñ€ÑÐ´ 1) - Ñ„Ñ€ÐµÐ¹Ð¼Ñ‹ 4,5,6,7
                this.anims.create({
                    key: 'walk-left',
                    frames: this.anims.generateFrameNumbers('playerSprite', { start: 4, end: 7 }),
                    frameRate: 8,
                    repeat: -1
                });

                // UP (Ð½Ð°Ð·Ð°Ð´/Ð²Ð²ÐµÑ€Ñ…, Ñ€ÑÐ´ 2) - Ñ„Ñ€ÐµÐ¹Ð¼Ñ‹ 8,9,10,11
                this.anims.create({
                    key: 'walk-up',
                    frames: this.anims.generateFrameNumbers('playerSprite', { start: 8, end: 11 }),
                    frameRate: 8,
                    repeat: -1
                });

                // RIGHT (Ð²Ð¿Ñ€Ð°Ð²Ð¾, Ñ€ÑÐ´ 3) - Ñ„Ñ€ÐµÐ¹Ð¼Ñ‹ 12,13,14,15
                this.anims.create({
                    key: 'walk-right',
                    frames: this.anims.generateFrameNumbers('playerSprite', { start: 12, end: 15 }),
                    frameRate: 8,
                    repeat: -1
                });

                // IDLE Ð°Ð½Ð¸Ð¼Ð°Ñ†Ð¸Ð¸ (ÑÑ‚Ð¾ÑÑ‰Ð¸Ð¹ Ð¿ÐµÑ€ÑÐ¾Ð½Ð°Ð¶ - ÐºÐ°Ð´Ñ€ 0 Ð¸Ð»Ð¸ 2 Ð² ÐºÐ°Ð¶Ð´Ð¾Ð¼ Ñ€ÑÐ´Ñƒ)
                this.anims.create({
                    key: 'idle-down',
                    frames: [{ key: 'playerSprite', frame: 0 }]
                });

                this.anims.create({
                    key: 'idle-left',
                    frames: [{ key: 'playerSprite', frame: 4 }]
                });

                this.anims.create({
                    key: 'idle-up',
                    frames: [{ key: 'playerSprite', frame: 8 }]
                });

                this.anims.create({
                    key: 'idle-right',
                    frames: [{ key: 'playerSprite', frame: 12 }]
                });
            }

            // ÐŸÐµÑ€ÑÐ¾Ð½Ð°Ð¶ â€” spawn inside walkable isometric floor area
            const fromStudio = this.scene.settings.data?.fromStudio;

            if (fromStudio) {
                // Coming from studio â€” spawn on floor between ottoman and right side
                this.player = this.physics.add.sprite(roomWidth * 0.50, roomHeight * 0.72, 'playerSprite');
            } else {
                // First time â€” spawn in center of floor (between sofa and ottoman)
                this.player = this.physics.add.sprite(roomWidth * 0.38, roomHeight * 0.75, 'playerSprite');
            }
            
            console.log('ðŸ‘¤ Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð¿ÐµÑ€ÑÐ¾Ð½Ð°Ð¶Ð°...');
            console.log('ðŸ‘¤ Texture exists?', this.textures.exists('playerSprite'));
            
            // Ð£Ð¼ÐµÐ½ÑŒÑˆÐ°ÐµÐ¼ Ñ€Ð°Ð·Ð¼ÐµÑ€ Ð¿ÐµÑ€ÑÐ¾Ð½Ð°Ð¶Ð°
            this.player.setScale(2);  // Ð‘Ñ‹Ð»Ð¾ 3, Ñ‚ÐµÐ¿ÐµÑ€ÑŒ 2
            this.player.setOrigin(0.5, 1); // Ð’ÐÐ–ÐÐž: origin Ð²Ð½Ð¸Ð·Ñƒ Ð¿Ð¾ Ñ†ÐµÐ½Ñ‚Ñ€Ñƒ (Ð´Ð»Ñ Ð½Ð¾Ð³)
            this.player.setCollideWorldBounds(true);
            
            // Ð¥Ð¸Ñ‚Ð±Ð¾ÐºÑ Ð´Ð»Ñ Ð½Ð¾Ð³
            this.player.body.setSize(20, 10);  // ÐœÐ°Ð»ÐµÐ½ÑŒÐºÐ¸Ð¹ Ñ…Ð¸Ñ‚Ð±Ð¾ÐºÑ
            this.player.body.setOffset(22, 54); // Ð¡Ð¼ÐµÑ‰ÐµÐ½Ð¸Ðµ Ðº ÑÐ°Ð¼Ð¾Ð¼Ñƒ Ð½Ð¸Ð·Ñƒ (Ð½Ð¾Ð³Ð¸)
            
            this.player.anims.play('idle-down');
            this.playerDirection = 'down';
            
            console.log('ðŸ‘¤ ÐŸÐµÑ€ÑÐ¾Ð½Ð°Ð¶ ÑÐ¾Ð·Ð´Ð°Ð½ Ð½Ð° Ð¿Ð¾Ð·Ð¸Ñ†Ð¸Ð¸:', this.player.x, this.player.y);
            console.log('ðŸ‘¤ Ð Ð°Ð·Ð¼ÐµÑ€ ÑÐ¿Ñ€Ð°Ð¹Ñ‚Ð°:', this.player.width, 'x', this.player.height);
            console.log('ðŸ‘¤ Frame size:', this.player.frame.width, 'x', this.player.frame.height);

            // ÐšÐÐœÐ•Ð Ð Ð’Ð¡Ð•Ð“Ð”Ð Ð¡Ð›Ð•Ð”Ð£Ð•Ð¢ Ð—Ð ÐŸÐ•Ð Ð¡ÐžÐÐÐ–Ð•Ðœ + Ð—Ð£Ðœ
            this.cameras.main.startFollow(this.player, true, 0.1, 0.1);
            this.cameras.main.setBounds(0, 0, roomWidth, roomHeight);
            this.cameras.main.setZoom(1.4); // Ð£Ð²ÐµÐ»Ð¸Ñ‡Ð¸Ð²Ð°ÐµÐ¼ Ð·ÑƒÐ¼
            this.cameras.main.fadeIn(1000, 0, 0, 0);

            this.targetX = null;
            this.targetY = null;
            this.isTransitioning = false;

            // --- WASD Ð£ÐŸÐ ÐÐ’Ð›Ð•ÐÐ˜Ð• ---
            this.cursors = this.input.keyboard.createCursorKeys();
            this.wasd = this.input.keyboard.addKeys({
                up: Phaser.Input.Keyboard.KeyCodes.W,
                down: Phaser.Input.Keyboard.KeyCodes.S,
                left: Phaser.Input.Keyboard.KeyCodes.A,
                right: Phaser.Input.Keyboard.KeyCodes.D
            });

            // --- Ð’Ð˜Ð Ð¢Ð£ÐÐ›Ð¬ÐÐ«Ð• Ð¡Ð¢Ð Ð•Ð›ÐšÐ˜ (Ð´Ð»Ñ Ð¼Ð¾Ð±Ð¸Ð»ÑŒÐ½Ñ‹Ñ…) ---
            const buttonSize = 80;
            const buttonAlpha = 0.6;
            const buttonColor = 0x444444;
            
            // Ð›ÐµÐ²Ð°Ñ ÑÑ‚Ñ€ÐµÐ»ÐºÐ°
            this.btnLeft = this.add.circle(120, screenHeight - 150, buttonSize/2, buttonColor, buttonAlpha);
            this.btnLeft.setScrollFactor(0).setInteractive();
            this.add.text(120, screenHeight - 150, 'â—„', {
                fontSize: '50px', color: '#ffffff'
            }).setOrigin(0.5).setScrollFactor(0);
            
            // ÐŸÑ€Ð°Ð²Ð°Ñ ÑÑ‚Ñ€ÐµÐ»ÐºÐ°
            this.btnRight = this.add.circle(280, screenHeight - 150, buttonSize/2, buttonColor, buttonAlpha);
            this.btnRight.setScrollFactor(0).setInteractive();
            this.add.text(280, screenHeight - 150, 'â–º', {
                fontSize: '50px', color: '#ffffff'
            }).setOrigin(0.5).setScrollFactor(0);
            
            // Ð’ÐµÑ€Ñ…Ð½ÑÑ ÑÑ‚Ñ€ÐµÐ»ÐºÐ°
            this.btnUp = this.add.circle(screenWidth - 120, screenHeight - 230, buttonSize/2, buttonColor, buttonAlpha);
            this.btnUp.setScrollFactor(0).setInteractive();
            this.add.text(screenWidth - 120, screenHeight - 230, 'â–²', {
                fontSize: '50px', color: '#ffffff'
            }).setOrigin(0.5).setScrollFactor(0);
            
            // ÐÐ¸Ð¶Ð½ÑÑ ÑÑ‚Ñ€ÐµÐ»ÐºÐ°
            this.btnDown = this.add.circle(screenWidth - 120, screenHeight - 70, buttonSize/2, buttonColor, buttonAlpha);
            this.btnDown.setScrollFactor(0).setInteractive();
            this.add.text(screenWidth - 120, screenHeight - 70, 'â–¼', {
                fontSize: '50px', color: '#ffffff'
            }).setOrigin(0.5).setScrollFactor(0);

            // Ð¡Ð¾ÑÑ‚Ð¾ÑÐ½Ð¸Ñ Ð²Ð¸Ñ€Ñ‚ÑƒÐ°Ð»ÑŒÐ½Ñ‹Ñ… ÐºÐ½Ð¾Ð¿Ð¾Ðº
            this.virtualInput = { left: false, right: false, up: false, down: false };

            this.btnLeft.on('pointerdown', () => { this.virtualInput.left = true; });
            this.btnLeft.on('pointerup', () => { this.virtualInput.left = false; });
            this.btnLeft.on('pointerout', () => { this.virtualInput.left = false; });

            this.btnRight.on('pointerdown', () => { this.virtualInput.right = true; });
            this.btnRight.on('pointerup', () => { this.virtualInput.right = false; });
            this.btnRight.on('pointerout', () => { this.virtualInput.right = false; });

            this.btnUp.on('pointerdown', () => { this.virtualInput.up = true; });
            this.btnUp.on('pointerup', () => { this.virtualInput.up = false; });
            this.btnUp.on('pointerout', () => { this.virtualInput.up = false; });

            this.btnDown.on('pointerdown', () => { this.virtualInput.down = true; });
            this.btnDown.on('pointerup', () => { this.virtualInput.down = false; });
            this.btnDown.on('pointerout', () => { this.virtualInput.down = false; });

            // ÐšÐ»Ð¸Ðº Ð¿Ð¾ ÐºÐ°Ñ€Ñ‚Ðµ (Ð¾ÑÑ‚Ð°Ð²Ð»ÑÐµÐ¼ Ð´Ð»Ñ PC)
            this.input.on('pointerdown', (pointer) => {
                if (this.isTransitioning) return;
                
                // Ð˜Ð³Ð½Ð¾Ñ€Ð¸Ñ€ÑƒÐµÐ¼ ÐºÐ»Ð¸ÐºÐ¸ Ð¿Ð¾ ÐºÐ½Ð¾Ð¿ÐºÐ°Ð¼
                if (pointer.y > screenHeight - 300) return;
                
                const worldPoint = this.cameras.main.getWorldPoint(pointer.x, pointer.y);
                this.targetX = worldPoint.x;
                this.targetY = worldPoint.y;
                this.physics.moveToObject(this.player, worldPoint, 250);
            });

            // === ROOM 1 â€” POLYGON-BASED ISOMETRIC COLLISIONS ===
            //
            // Instead of axis-aligned rectangles, we define the walkable floor
            // as isometric polygons matching the actual visible floor tiles.
            // The update() loop checks if player feet are inside walkable area.
            //
            // ROOM 1 FLOOR LAYOUT (from movement image):
            // The walkable area traces the actual floor visible between furniture.
            // In isometric view, "up-left" on screen = north in game world.
            //
            // Walkable zone = outer polygon MINUS ottoman polygon (hole).
            //
            // Outer walkable polygon (tracing red lines from image):
            // The red boundary follows the floor edges between sofa and TV stand.
            //   P1: left of sofa bottom-front â†’ going clockwise
            //
            // Looking at the image carefully:
            //   - Sofa is on the LEFT wall, takes up the left portion
            //   - Ottoman/pouf is in the CENTER of the floor
            //   - TV stand is along the BACK wall (top of isometric view)
            //   - Door is on the RIGHT wall
            //   - Floor is visible as a diamond between all furniture
            //
            // The red boundary in the image forms a shape following the floor:

            // Store walkable polygon and ottoman polygon for update() checks
            // All coordinates as fractions of roomWidth/roomHeight

            // OUTER walkable boundary â€” traces the FLOOR ONLY
            // Carefully traced from movement image (room1_movements.png)
            //
            // The red rectangle in the image follows the isometric floor edges:
            //   - LEFT side: runs along the sofa's RIGHT arm (inner edge facing floor)
            //   - TOP side: runs along the TV stand's BOTTOM edge (floor in front of TV)
            //   - RIGHT side: runs along the door area / right wall floor edge
            //   - BOTTOM side: the front visible floor edge
            //
            // Going clockwise from top-left
            this.walkablePolygon = [
                { x: 0.22, y: 0.55 },  // Top-left: where sofa meets TV stand area (floor only)
                { x: 0.48, y: 0.42 },  // Top-center: floor edge right below TV stand
                { x: 0.68, y: 0.50 },  // Top-right: floor near door / right of TV stand
                { x: 0.82, y: 0.58 },  // Right: floor in front of door
                { x: 0.72, y: 0.82 },  // Bottom-right: right side floor front edge
                { x: 0.50, y: 0.93 },  // Bottom-center: front floor tip
                { x: 0.22, y: 0.82 },  // Bottom-left: front of sofa, floor edge
                { x: 0.18, y: 0.72 },  // Left-bottom: sofa arm inner edge (floor side)
                { x: 0.18, y: 0.62 },  // Left: alongside sofa inner arm going up
            ];

            // OTTOMAN / POUF â€” centered on the actual ottoman furniture
            // Traced tightly around the ottoman visible in the room
            this.ottomanPolygon = [
                { x: 0.28, y: 0.58 },  // Top-left of ottoman
                { x: 0.42, y: 0.52 },  // Top-right of ottoman
                { x: 0.48, y: 0.58 },  // Right of ottoman
                { x: 0.42, y: 0.66 },  // Bottom-right of ottoman
                { x: 0.28, y: 0.68 },  // Bottom-left of ottoman
                { x: 0.24, y: 0.63 },  // Left of ottoman
            ];

            this.roomWidth = roomWidth;
            this.roomHeight = roomHeight;

            // GREEN TRANSITION LINE â€” diagonal from movement image
            // In the image: green line goes from bottom-center area toward upper-right
            // roughly from (0.44, 0.86) to (0.74, 0.60) â€” a "/" diagonal
            this.greenLineStart = { x: 0.44, y: 0.86 };
            this.greenLineEnd = { x: 0.74, y: 0.60 };

            // Locked door zone (right wall â€” isometric diamond near the door)
            this.lockedDoorPoly = [
                { x: 0.74, y: 0.48 },
                { x: 0.86, y: 0.52 },
                { x: 0.86, y: 0.62 },
                { x: 0.74, y: 0.58 },
            ];
            this.lockedDoorMessage = this.add.text(roomWidth * 0.75, roomHeight * 0.35,
                'Ð•Ñ‰Ðµ Ð½Ðµ Ð²Ñ€ÐµÐ¼Ñ', {
                fontSize: '48px',
                fontFamily: 'Courier New',
                color: '#ffffff',
                backgroundColor: '#000000',
                padding: { x: 25, y: 12 },
                alpha: 0
            }).setOrigin(0.5).setDepth(100);
            this.lockedDoorTimer = 0;

            // DEBUG: Draw the polygons so we can see them
            const debugGfx = this.add.graphics();
            debugGfx.setDepth(50);

            // Draw outer walkable polygon (red outline)
            debugGfx.lineStyle(3, 0xff0000, 0.8);
            debugGfx.beginPath();
            this.walkablePolygon.forEach((p, i) => {
                const px = p.x * roomWidth;
                const py = p.y * roomHeight;
                if (i === 0) debugGfx.moveTo(px, py);
                else debugGfx.lineTo(px, py);
            });
            debugGfx.closePath();
            debugGfx.strokePath();

            // Draw ottoman (red filled)
            debugGfx.lineStyle(3, 0xff0000, 0.8);
            debugGfx.fillStyle(0xff0000, 0.15);
            debugGfx.beginPath();
            this.ottomanPolygon.forEach((p, i) => {
                const px = p.x * roomWidth;
                const py = p.y * roomHeight;
                if (i === 0) debugGfx.moveTo(px, py);
                else debugGfx.lineTo(px, py);
            });
            debugGfx.closePath();
            debugGfx.strokePath();
            debugGfx.fillPath();

            // Draw green transition line
            debugGfx.lineStyle(4, 0x00ff00, 0.8);
            debugGfx.beginPath();
            debugGfx.moveTo(this.greenLineStart.x * roomWidth, this.greenLineStart.y * roomHeight);
            debugGfx.lineTo(this.greenLineEnd.x * roomWidth, this.greenLineEnd.y * roomHeight);
            debugGfx.strokePath();

            // Draw locked door zone
            debugGfx.lineStyle(2, 0xffff00, 0.6);
            debugGfx.beginPath();
            this.lockedDoorPoly.forEach((p, i) => {
                if (i === 0) debugGfx.moveTo(p.x * roomWidth, p.y * roomHeight);
                else debugGfx.lineTo(p.x * roomWidth, p.y * roomHeight);
            });
            debugGfx.closePath();
            debugGfx.strokePath();

            // Disable physics world bounds â€” we handle collision ourselves
            this.player.setCollideWorldBounds(false);
        }

        // Point-in-polygon test (ray casting algorithm)
        pointInPolygon(px, py, polygon, rw, rh) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x * rw, yi = polygon[i].y * rh;
                const xj = polygon[j].x * rw, yj = polygon[j].y * rh;
                const intersect = ((yi > py) !== (yj > py)) &&
                    (px < (xj - xi) * (py - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        // Check distance from point to a line segment (for green transition)
        pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1;
            const B = py - y1;
            const C = x2 - x1;
            const D = y2 - y1;
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let t = lenSq !== 0 ? dot / lenSq : -1;
            t = Math.max(0, Math.min(1, t));
            const xx = x1 + t * C;
            const yy = y1 + t * D;
            return Math.sqrt((px - xx) * (px - xx) + (py - yy) * (py - yy));
        }

        update() {
            const moveSpeed = 250;
            const rw = this.roomWidth;
            const rh = this.roomHeight;
            let vx = 0;
            let vy = 0;

            // WASD + arrow keys + virtual buttons
            const left = this.wasd.left.isDown || this.cursors.left.isDown || this.virtualInput.left;
            const right = this.wasd.right.isDown || this.cursors.right.isDown || this.virtualInput.right;
            const up = this.wasd.up.isDown || this.cursors.up.isDown || this.virtualInput.up;
            const down = this.wasd.down.isDown || this.cursors.down.isDown || this.virtualInput.down;

            if (left) vx = -moveSpeed;
            else if (right) vx = moveSpeed;
            if (up) vy = -moveSpeed;
            else if (down) vy = moveSpeed;

            const usingKeyboard = left || right || up || down;

            if (usingKeyboard) {
                this.targetX = null;
                this.targetY = null;
            }

            // Click-to-move: stop when close to target
            if (this.targetX !== null && this.targetY !== null) {
                const distance = Phaser.Math.Distance.Between(
                    this.player.x, this.player.y,
                    this.targetX, this.targetY
                );
                if (distance < 10) {
                    this.targetX = null;
                    this.targetY = null;
                } else {
                    const angle = Math.atan2(this.targetY - this.player.y, this.targetX - this.player.x);
                    vx = Math.cos(angle) * moveSpeed;
                    vy = Math.sin(angle) * moveSpeed;
                }
            }

            // --- POLYGON COLLISION CHECK ---
            const dt = this.game.loop.delta / 1000;
            const nextX = this.player.x + vx * dt;
            const nextY = this.player.y + vy * dt;

            const inOuter = this.pointInPolygon(nextX, nextY, this.walkablePolygon, rw, rh);
            const inOttoman = this.pointInPolygon(nextX, nextY, this.ottomanPolygon, rw, rh);

            if (inOuter && !inOttoman) {
                // Movement is valid
                this.player.body.setVelocity(vx, vy);
            } else {
                // Try sliding: allow X movement only
                const slideX_x = this.player.x + vx * dt;
                const slideX_y = this.player.y;
                const xOk = this.pointInPolygon(slideX_x, slideX_y, this.walkablePolygon, rw, rh)
                          && !this.pointInPolygon(slideX_x, slideX_y, this.ottomanPolygon, rw, rh);

                // Try sliding: allow Y movement only
                const slideY_x = this.player.x;
                const slideY_y = this.player.y + vy * dt;
                const yOk = this.pointInPolygon(slideY_x, slideY_y, this.walkablePolygon, rw, rh)
                          && !this.pointInPolygon(slideY_x, slideY_y, this.ottomanPolygon, rw, rh);

                if (xOk && !yOk) {
                    this.player.body.setVelocity(vx, 0);
                } else if (yOk && !xOk) {
                    this.player.body.setVelocity(0, vy);
                } else {
                    this.player.body.setVelocity(0, 0);
                }
            }

            // If no input and no click target, stop
            if (!usingKeyboard && this.targetX === null) {
                this.player.body.setVelocity(0, 0);
            }

            // --- GREEN LINE TRANSITION CHECK ---
            if (!this.isTransitioning) {
                const dist = this.pointToLineDistance(
                    this.player.x, this.player.y,
                    this.greenLineStart.x * rw, this.greenLineStart.y * rh,
                    this.greenLineEnd.x * rw, this.greenLineEnd.y * rh
                );
                if (dist < 30) {
                    this.isTransitioning = true;
                    this.player.body.setVelocity(0, 0);
                    this.cameras.main.fadeOut(800, 0, 0, 0);
                    this.time.delayedCall(800, () => {
                        this.scene.start('StudioScene', { fromLiving: true });
                    });
                }
            }

            // --- LOCKED DOOR CHECK ---
            if (this.pointInPolygon(this.player.x, this.player.y, this.lockedDoorPoly, rw, rh)) {
                if (this.lockedDoorTimer <= 0) {
                    this.lockedDoorTimer = 2500;
                    this.tweens.add({ targets: this.lockedDoorMessage, alpha: 1, duration: 300 });
                    this.time.delayedCall(2500, () => {
                        this.tweens.add({ targets: this.lockedDoorMessage, alpha: 0, duration: 300 });
                    });
                }
            }
            if (this.lockedDoorTimer > 0) this.lockedDoorTimer -= this.game.loop.delta;

            // --- ANIMATION ---
            const speed = this.player.body.velocity.length();
            if (speed > 10) {
                const angle = Math.atan2(this.player.body.velocity.y, this.player.body.velocity.x);
                const deg = Phaser.Math.RadToDeg(angle);
                if (deg > -45 && deg <= 45) { this.player.anims.play('walk-right', true); this.playerDirection = 'right'; }
                else if (deg > 45 && deg <= 135) { this.player.anims.play('walk-down', true); this.playerDirection = 'down'; }
                else if (deg > 135 || deg <= -135) { this.player.anims.play('walk-left', true); this.playerDirection = 'left'; }
                else { this.player.anims.play('walk-up', true); this.playerDirection = 'up'; }
            } else {
                this.player.anims.play('idle-' + this.playerDirection, true);
            }
        }
    }

    // --- Ð¡Ð¢Ð£Ð”Ð˜Ð¯ ---
    class StudioScene extends Phaser.Scene {
        constructor() { super('StudioScene'); }

        preload() {
            this.load.image('room2', 'room2_right_size.png');
        }

        create() {
            const screenWidth = this.scale.width;
            const screenHeight = this.scale.height;

            const bg = this.add.image(0, 0, 'room2').setOrigin(0, 0);
            
            const scaleX = screenWidth / bg.width;
            const scaleY = screenHeight / bg.height;
            const scale = Math.max(scaleX, scaleY);
            
            bg.setScale(scale);
            
            const roomWidth = bg.width * scale;
            const roomHeight = bg.height * scale;

            this.physics.world.setBounds(0, 0, roomWidth, roomHeight);

            // ÐŸÐµÑ€ÑÐ¾Ð½Ð°Ð¶ â€” spawn inside walkable isometric floor area
            const fromLiving = this.scene.settings.data?.fromLiving;

            if (fromLiving) {
                // Coming from living room â€” spawn in center of studio floor
                this.player = this.physics.add.sprite(roomWidth * 0.40, roomHeight * 0.70, 'playerSprite');
            } else {
                // First time
                this.player = this.physics.add.sprite(roomWidth * 0.40, roomHeight * 0.80, 'playerSprite');
            }
            
            this.player.setScale(2);
            this.player.setOrigin(0.5, 1);
            this.player.setCollideWorldBounds(true);
            this.player.body.setSize(20, 10);
            this.player.body.setOffset(22, 54);
            this.player.anims.play('idle-down');
            this.playerDirection = 'down';

            // ÐšÐÐœÐ•Ð Ð + Ð—Ð£Ðœ
            this.cameras.main.startFollow(this.player, true, 0.1, 0.1);
            this.cameras.main.setBounds(0, 0, roomWidth, roomHeight);
            this.cameras.main.setZoom(1.4);
            this.cameras.main.fadeIn(1000, 0, 0, 0);

            this.targetX = null;
            this.targetY = null;
            this.isTransitioning = false;

            // --- WASD Ð£ÐŸÐ ÐÐ’Ð›Ð•ÐÐ˜Ð• ---
            this.cursors = this.input.keyboard.createCursorKeys();
            this.wasd = this.input.keyboard.addKeys({
                up: Phaser.Input.Keyboard.KeyCodes.W,
                down: Phaser.Input.Keyboard.KeyCodes.S,
                left: Phaser.Input.Keyboard.KeyCodes.A,
                right: Phaser.Input.Keyboard.KeyCodes.D
            });

            // --- Ð’Ð˜Ð Ð¢Ð£ÐÐ›Ð¬ÐÐ«Ð• Ð¡Ð¢Ð Ð•Ð›ÐšÐ˜ (Ð´Ð»Ñ Ð¼Ð¾Ð±Ð¸Ð»ÑŒÐ½Ñ‹Ñ…) ---
            const buttonSize = 80;
            const buttonAlpha = 0.6;
            const buttonColor = 0x444444;

            this.btnLeft = this.add.circle(120, screenHeight - 150, buttonSize/2, buttonColor, buttonAlpha);
            this.btnLeft.setScrollFactor(0).setInteractive();
            this.add.text(120, screenHeight - 150, 'â—„', { fontSize: '50px', color: '#ffffff' }).setOrigin(0.5).setScrollFactor(0);

            this.btnRight = this.add.circle(280, screenHeight - 150, buttonSize/2, buttonColor, buttonAlpha);
            this.btnRight.setScrollFactor(0).setInteractive();
            this.add.text(280, screenHeight - 150, 'â–º', { fontSize: '50px', color: '#ffffff' }).setOrigin(0.5).setScrollFactor(0);

            this.btnUp = this.add.circle(screenWidth - 120, screenHeight - 230, buttonSize/2, buttonColor, buttonAlpha);
            this.btnUp.setScrollFactor(0).setInteractive();
            this.add.text(screenWidth - 120, screenHeight - 230, 'â–²', { fontSize: '50px', color: '#ffffff' }).setOrigin(0.5).setScrollFactor(0);

            this.btnDown = this.add.circle(screenWidth - 120, screenHeight - 70, buttonSize/2, buttonColor, buttonAlpha);
            this.btnDown.setScrollFactor(0).setInteractive();
            this.add.text(screenWidth - 120, screenHeight - 70, 'â–¼', { fontSize: '50px', color: '#ffffff' }).setOrigin(0.5).setScrollFactor(0);

            this.virtualInput = { left: false, right: false, up: false, down: false };

            this.btnLeft.on('pointerdown', () => { this.virtualInput.left = true; });
            this.btnLeft.on('pointerup', () => { this.virtualInput.left = false; });
            this.btnLeft.on('pointerout', () => { this.virtualInput.left = false; });
            this.btnRight.on('pointerdown', () => { this.virtualInput.right = true; });
            this.btnRight.on('pointerup', () => { this.virtualInput.right = false; });
            this.btnRight.on('pointerout', () => { this.virtualInput.right = false; });
            this.btnUp.on('pointerdown', () => { this.virtualInput.up = true; });
            this.btnUp.on('pointerup', () => { this.virtualInput.up = false; });
            this.btnUp.on('pointerout', () => { this.virtualInput.up = false; });
            this.btnDown.on('pointerdown', () => { this.virtualInput.down = true; });
            this.btnDown.on('pointerup', () => { this.virtualInput.down = false; });
            this.btnDown.on('pointerout', () => { this.virtualInput.down = false; });

            // ÐšÐ»Ð¸Ðº Ð¿Ð¾ ÐºÐ°Ñ€Ñ‚Ðµ
            this.input.on('pointerdown', (pointer) => {
                if (this.isTransitioning) return;
                if (pointer.y > screenHeight - 300) return;

                const worldPoint = this.cameras.main.getWorldPoint(pointer.x, pointer.y);
                this.targetX = worldPoint.x;
                this.targetY = worldPoint.y;
                this.physics.moveToObject(this.player, worldPoint, 250);
            });

            // === ROOM 2 â€” POLYGON-BASED ISOMETRIC COLLISIONS ===
            //
            // Studio room walkable area traced from movement image.
            // The red boundary follows the floor edges between desk, chair, couch, door.
            // The floor is an L-shaped area with furniture blocking certain zones.
            //
            // Key furniture blocking zones:
            //   - Desk + monitors (back-left corner)
            //   - Chair (center-left, in front of desk)
            //   - Shelf (back wall behind desk)
            //   - Couch (right side)
            //   - Plant (back-right corner)
            //
            // Walkable floor = the visible wood floor between all furniture

            // Walkable polygon â€” traces the FLOOR ONLY in isometric view
            // Carefully traced from movement image (room2_movements.png)
            //
            // The red boundary follows the floor edges:
            //   - LEFT side: alongside the door, up to desk/shelf area
            //   - TOP: runs along desk bottom, around chair, along couch back
            //   - RIGHT: runs along couch right arm edge
            //   - BOTTOM: front floor edge
            //
            // The L-shape comes from the desk+chair blocking the upper-left
            // and the couch blocking the upper-right
            //
            // Going clockwise from top-left
            this.walkablePolygon = [
                { x: 0.12, y: 0.65 },  // Top-left: floor next to door, below desk
                { x: 0.22, y: 0.58 },  // Up: floor edge below desk/shelf area
                { x: 0.38, y: 0.54 },  // Top-center-left: floor gap between desk/chair area
                { x: 0.50, y: 0.52 },  // Top-center: open floor between chair and couch
                { x: 0.58, y: 0.54 },  // Top-center-right: near couch
                { x: 0.68, y: 0.58 },  // Top-right: floor below couch back
                { x: 0.72, y: 0.65 },  // Right: couch front-right edge
                { x: 0.62, y: 0.90 },  // Bottom-right: right front floor edge
                { x: 0.42, y: 0.95 },  // Bottom-center: front floor tip
                { x: 0.18, y: 0.88 },  // Bottom-left: left front floor edge
                { x: 0.08, y: 0.76 },  // Left-bottom: door area floor
                { x: 0.08, y: 0.70 },  // Left: alongside door going up
            ];

            // Chair â€” island blocking area (the desk chair in center-left)
            this.chairPolygon = [
                { x: 0.28, y: 0.64 },  // Top-left
                { x: 0.38, y: 0.60 },  // Top-right
                { x: 0.44, y: 0.66 },  // Right
                { x: 0.40, y: 0.74 },  // Bottom-right
                { x: 0.30, y: 0.76 },  // Bottom-left
                { x: 0.25, y: 0.70 },  // Left
            ];

            this.roomWidth = roomWidth;
            this.roomHeight = roomHeight;

            // GREEN TRANSITION LINE â€” diagonal "\" from movement image
            // In the image: green line goes from left side down to right bottom
            // roughly from (0.12, 0.76) to (0.58, 0.92) â€” a "\" diagonal
            this.greenLineStart = { x: 0.20, y: 0.85 };
            this.greenLineEnd = { x: 0.80, y: 0.70 };

            // Locked door zone (left wall â€” near the door)
            this.lockedDoorPoly = [
                { x: 0.04, y: 0.58 },
                { x: 0.14, y: 0.52 },
                { x: 0.14, y: 0.62 },
                { x: 0.04, y: 0.68 },
            ];
            this.lockedDoorMessage = this.add.text(roomWidth * 0.20, roomHeight * 0.45,
                'Ð•Ñ‰Ðµ Ð½Ðµ Ð²Ñ€ÐµÐ¼Ñ', {
                fontSize: '48px',
                fontFamily: 'Courier New',
                color: '#ffffff',
                backgroundColor: '#000000',
                padding: { x: 25, y: 12 },
                alpha: 0
            }).setOrigin(0.5).setDepth(100);
            this.lockedDoorTimer = 0;

            // DEBUG: Draw the polygons
            const debugGfx = this.add.graphics();
            debugGfx.setDepth(50);

            // Outer walkable polygon (red outline)
            debugGfx.lineStyle(3, 0xff0000, 0.8);
            debugGfx.beginPath();
            this.walkablePolygon.forEach((p, i) => {
                const px = p.x * roomWidth;
                const py = p.y * roomHeight;
                if (i === 0) debugGfx.moveTo(px, py);
                else debugGfx.lineTo(px, py);
            });
            debugGfx.closePath();
            debugGfx.strokePath();

            // Chair polygon (red filled)
            debugGfx.lineStyle(3, 0xff0000, 0.8);
            debugGfx.fillStyle(0xff0000, 0.15);
            debugGfx.beginPath();
            this.chairPolygon.forEach((p, i) => {
                const px = p.x * roomWidth;
                const py = p.y * roomHeight;
                if (i === 0) debugGfx.moveTo(px, py);
                else debugGfx.lineTo(px, py);
            });
            debugGfx.closePath();
            debugGfx.strokePath();
            debugGfx.fillPath();

            // Green transition line
            debugGfx.lineStyle(4, 0x00ff00, 0.8);
            debugGfx.beginPath();
            debugGfx.moveTo(this.greenLineStart.x * roomWidth, this.greenLineStart.y * roomHeight);
            debugGfx.lineTo(this.greenLineEnd.x * roomWidth, this.greenLineEnd.y * roomHeight);
            debugGfx.strokePath();

            // Locked door zone
            debugGfx.lineStyle(2, 0xffff00, 0.6);
            debugGfx.beginPath();
            this.lockedDoorPoly.forEach((p, i) => {
                if (i === 0) debugGfx.moveTo(p.x * roomWidth, p.y * roomHeight);
                else debugGfx.lineTo(p.x * roomWidth, p.y * roomHeight);
            });
            debugGfx.closePath();
            debugGfx.strokePath();

            // Disable physics world bounds â€” we handle collision ourselves
            this.player.setCollideWorldBounds(false);
        }

        // Point-in-polygon test (ray casting algorithm)
        pointInPolygon(px, py, polygon, rw, rh) {
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const xi = polygon[i].x * rw, yi = polygon[i].y * rh;
                const xj = polygon[j].x * rw, yj = polygon[j].y * rh;
                const intersect = ((yi > py) !== (yj > py)) &&
                    (px < (xj - xi) * (py - yi) / (yj - yi) + xi);
                if (intersect) inside = !inside;
            }
            return inside;
        }

        pointToLineDistance(px, py, x1, y1, x2, y2) {
            const A = px - x1, B = py - y1, C = x2 - x1, D = y2 - y1;
            const dot = A * C + B * D;
            const lenSq = C * C + D * D;
            let t = lenSq !== 0 ? dot / lenSq : -1;
            t = Math.max(0, Math.min(1, t));
            const xx = x1 + t * C, yy = y1 + t * D;
            return Math.sqrt((px - xx) * (px - xx) + (py - yy) * (py - yy));
        }

        update() {
            const moveSpeed = 250;
            const rw = this.roomWidth;
            const rh = this.roomHeight;
            let vx = 0;
            let vy = 0;

            const left = this.wasd.left.isDown || this.cursors.left.isDown || this.virtualInput.left;
            const right = this.wasd.right.isDown || this.cursors.right.isDown || this.virtualInput.right;
            const up = this.wasd.up.isDown || this.cursors.up.isDown || this.virtualInput.up;
            const down = this.wasd.down.isDown || this.cursors.down.isDown || this.virtualInput.down;

            if (left) vx = -moveSpeed;
            else if (right) vx = moveSpeed;
            if (up) vy = -moveSpeed;
            else if (down) vy = moveSpeed;

            const usingKeyboard = left || right || up || down;

            if (usingKeyboard) {
                this.targetX = null;
                this.targetY = null;
            }

            if (this.targetX !== null && this.targetY !== null) {
                const distance = Phaser.Math.Distance.Between(
                    this.player.x, this.player.y, this.targetX, this.targetY
                );
                if (distance < 10) {
                    this.targetX = null;
                    this.targetY = null;
                } else {
                    const angle = Math.atan2(this.targetY - this.player.y, this.targetX - this.player.x);
                    vx = Math.cos(angle) * moveSpeed;
                    vy = Math.sin(angle) * moveSpeed;
                }
            }

            // --- POLYGON COLLISION CHECK ---
            const dt = this.game.loop.delta / 1000;
            const nextX = this.player.x + vx * dt;
            const nextY = this.player.y + vy * dt;

            const inOuter = this.pointInPolygon(nextX, nextY, this.walkablePolygon, rw, rh);
            const inChair = this.pointInPolygon(nextX, nextY, this.chairPolygon, rw, rh);

            if (inOuter && !inChair) {
                this.player.body.setVelocity(vx, vy);
            } else {
                const slideX_x = this.player.x + vx * dt;
                const slideX_y = this.player.y;
                const xOk = this.pointInPolygon(slideX_x, slideX_y, this.walkablePolygon, rw, rh)
                          && !this.pointInPolygon(slideX_x, slideX_y, this.chairPolygon, rw, rh);

                const slideY_x = this.player.x;
                const slideY_y = this.player.y + vy * dt;
                const yOk = this.pointInPolygon(slideY_x, slideY_y, this.walkablePolygon, rw, rh)
                          && !this.pointInPolygon(slideY_x, slideY_y, this.chairPolygon, rw, rh);

                if (xOk && !yOk) this.player.body.setVelocity(vx, 0);
                else if (yOk && !xOk) this.player.body.setVelocity(0, vy);
                else this.player.body.setVelocity(0, 0);
            }

            if (!usingKeyboard && this.targetX === null) {
                this.player.body.setVelocity(0, 0);
            }

            // --- GREEN LINE TRANSITION CHECK ---
            if (!this.isTransitioning) {
                const dist = this.pointToLineDistance(
                    this.player.x, this.player.y,
                    this.greenLineStart.x * rw, this.greenLineStart.y * rh,
                    this.greenLineEnd.x * rw, this.greenLineEnd.y * rh
                );
                if (dist < 30) {
                    this.isTransitioning = true;
                    this.player.body.setVelocity(0, 0);
                    this.cameras.main.fadeOut(800, 0, 0, 0);
                    this.time.delayedCall(800, () => {
                        this.scene.start('MainScene', { fromStudio: true });
                    });
                }
            }

            // --- LOCKED DOOR CHECK ---
            if (this.pointInPolygon(this.player.x, this.player.y, this.lockedDoorPoly, rw, rh)) {
                if (this.lockedDoorTimer <= 0) {
                    this.lockedDoorTimer = 2500;
                    this.tweens.add({ targets: this.lockedDoorMessage, alpha: 1, duration: 300 });
                    this.time.delayedCall(2500, () => {
                        this.tweens.add({ targets: this.lockedDoorMessage, alpha: 0, duration: 300 });
                    });
                }
            }
            if (this.lockedDoorTimer > 0) this.lockedDoorTimer -= this.game.loop.delta;

            // --- ANIMATION ---
            const speed = this.player.body.velocity.length();
            if (speed > 10) {
                const angle = Math.atan2(this.player.body.velocity.y, this.player.body.velocity.x);
                const deg = Phaser.Math.RadToDeg(angle);
                if (deg > -45 && deg <= 45) { this.player.anims.play('walk-right', true); this.playerDirection = 'right'; }
                else if (deg > 45 && deg <= 135) { this.player.anims.play('walk-down', true); this.playerDirection = 'down'; }
                else if (deg > 135 || deg <= -135) { this.player.anims.play('walk-left', true); this.playerDirection = 'left'; }
                else { this.player.anims.play('walk-up', true); this.playerDirection = 'up'; }
            } else {
                this.player.anims.play('idle-' + this.playerDirection, true);
            }
        }
    }

    // --- ÐšÐžÐÐ¤Ð˜Ð“Ð£Ð ÐÐ¦Ð˜Ð¯ ---
    const config = {
        type: Phaser.AUTO,
        backgroundColor: 'transparent', // Ð’ÐÐ–ÐÐž: Ð¿Ñ€Ð¾Ð·Ñ€Ð°Ñ‡Ð½Ñ‹Ð¹ Ñ„Ð¾Ð½ Ð´Ð»Ñ Canvas
        scale: {
            mode: Phaser.Scale.FIT,
            autoCenter: Phaser.Scale.CENTER_BOTH,
            width: 1080,
            height: 1920
        },
        physics: {
            default: 'arcade',
            arcade: {
                debug: true,
                gravity: { y: 0 }
            }
        },
        render: {
            antialias: false,  // ÐžÑ‚ÐºÐ»ÑŽÑ‡Ð°ÐµÐ¼ Ð°Ð½Ñ‚Ð¸Ð°Ð»Ð¸Ð°ÑÐ¸Ð½Ð³ Ð´Ð»Ñ Ð¿Ð¸ÐºÑÐµÐ»ÑŒ-Ð°Ñ€Ñ‚Ð°
            pixelArt: true,    // ÐšÐ Ð˜Ð¢Ð˜Ð§ÐÐž: Ð²ÐºÐ»ÑŽÑ‡Ð°ÐµÐ¼ Ñ€ÐµÐ¶Ð¸Ð¼ Ð¿Ð¸ÐºÑÐµÐ»ÑŒ-Ð°Ñ€Ñ‚Ð°
            transparent: true  // ÐŸÑ€Ð¾Ð·Ñ€Ð°Ñ‡Ð½Ð¾ÑÑ‚ÑŒ
        },
        scene: [MenuScene, MainScene, StudioScene]
    };

    const game = new Phaser.Game(config);
</script>
</body>
</html>